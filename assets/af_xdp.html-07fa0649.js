import{_ as e,W as a,X as i,Y as r}from"./framework-2fbbe1ff.js";const d="/assets/ebpf-xdp-95932e2a.png",n={},t=r('<h1 id="af-xdp" tabindex="-1"><a class="header-anchor" href="#af-xdp" aria-hidden="true">#</a> af_xdp</h1><h2 id="说明" tabindex="-1"><a class="header-anchor" href="#说明" aria-hidden="true">#</a> 说明</h2><p>bpf bsd packet filter，能以安全的方式在不同的钩点执行用户注入到内核的字节码。2013 年 Alexei Starovoitov 对 BPF 进行了改造，有了 eBPF</p><h2 id="xdp" tabindex="-1"><a class="header-anchor" href="#xdp" aria-hidden="true">#</a> XDP</h2><p>eBFP 有很多钩子，而 XDP 就是 linux 网络数据处理的一个 hook 点。XDP 全称 eXPress Data Path，快速数据路径，能够在数据到达网卡驱动时对其进行处理。</p><p>三种运行模式：generic，native，offload。</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>offload 是直接在网卡中对 xdp 程序进行处理，挂载点最靠前，性能最佳，但是需要硬件特别支持</p><p>native 是最传统的 xdp 模式，需要驱动支持，目前主流网卡驱动都实现了 native xdp，挂载在驱动接受路径上</p><p>generic 是内核模拟出的一种通用模式，不需要驱动支持，但是 xdp 挂载最靠后，性能不如 native</p><h2 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程" aria-hidden="true">#</a> 工作流程</h2><p>af_xdp 分为两个部分：socket 和 UMEM</p><h3 id="socket" tabindex="-1"><a class="header-anchor" href="#socket" aria-hidden="true">#</a> socket</h3><p>类似传统 socket，通过 socket()创建一个 xsk，每个 xsk 包含一个 RX ring 和 TX ring，收包在 RX ring 进行，发包在 TX ring 进行</p><h3 id="umem" tabindex="-1"><a class="header-anchor" href="#umem" aria-hidden="true">#</a> UMEM</h3><p>存放大小相等的内存块地址，包含两个 FILL ring 和 COMPLETION ring。</p><p>收包前，将包地址写到 FILL ring，内核消费这些数据收包，完成收包后地址放到 xsk 的 RX ring 中，用户程序消费 ring 得到数据帧</p><p>发包时，用户向 UMEM 的地址中写数据帧，写到 TX ring，内核消费开始执行发包，完成后写到 COMPLETION ring。</p><p>为了让 xsk 成功收包从网卡中，需要将 xsk 绑定到网卡和队列。</p>',19),p=[t];function s(h,c){return a(),i("div",null,p)}const f=e(n,[["render",s],["__file","af_xdp.html.vue"]]);export{f as default};
