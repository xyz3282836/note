import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{o as b,c,a as o}from"./app-08e26ff4.js";const e={},i=o('<h1 id="gcc" tabindex="-1"><a class="header-anchor" href="#gcc" aria-hidden="true">#</a> gcc</h1><p><strong>GCC 参数详解</strong></p><p>[介绍]<br> gcc and g++分别是 gnu 的 c &amp; c++编译器<br> gcc/g++在执行编译工作的时候，总共需要 4 步 1.预处理，生成.i 的文件 2.将预处理后的文件转换成汇编语言，生成文件.s 3.由汇编变为目标代码(机器代码)，生成.o 的文件 4.连接目标代码，生成可执行程序</p><p>[参数详解]<br> -c<br> 　　只激活预处理,编译,和汇编,也就是他只把程序做成 obj 文件<br> 　　例子用法:<br> 　　 gcc -c hello.c<br> 　　他将生成.o 的 obj 文件<br> -S<br> 　　只激活预处理和编译，就是指把文件编译成为汇编代码。<br> 　　例子用法<br> 　　 gcc -S hello.c<br> 　　他将生成.s 的汇编代码，你可以用文本编辑器察看<br> -E<br> 　　只激活预处理,这个不生成文件,你需要把它重定向到一个输出文件里<br> 　　面.<br> 　　例子用法:<br> 　　 gcc -E hello.c &gt; pianoapan.txt<br> 　　 gcc -E hello.c | more<br> 　　慢慢看吧,一个 hello word 也要与处理成 800 行的代码<br> -o<br> 　　制定目标名称,缺省的时候,gcc 编译出来的文件是 a.out,很难听,如果<br> 　　你和我有同感，改掉它,哈哈<br> 　　例子用法<br> 　　 gcc -o hello.exe hello.c (哦,windows 用习惯了)<br> 　　 gcc -o hello.asm -S hello.c<br> -ansi<br> 　　关闭 gnu c 中与 ansi c 不兼容的特性,激活 ansi c 的专有特性(包括禁止一些 asm inline typeof 关键字,以及 UNIX,vax 等预处理宏,</p><p>-wall</p><p>​ 显示警告信息<br> -fno-asm<br> 　　此选项实现 ansi 选项的功能的一部分，它禁止将 asm,inline 和 typeof 用作<br> 　　关键字。<br> -fno-strict-prototype<br> 　　只对 g++起作用,使用这个选项,g++将对不带参数的函数,都认为是没有显式<br> 　　的对参数的个数和类型说明,而不是没有参数.<br> 　　而 gcc 无论是否使用这个参数,都将对没有带参数的函数,认为城没有显式说<br> 　　明的类型<br> -fthis-is-varialble<br> 　　就是向传统 c++看齐,可以使用 this 当一般变量使用.<br> -fcond-mismatch<br> 　　允许条件表达式的第二和第三参数类型不匹配,表达式的值将为 void 类型<br> -funsigned-char<br> -fno-signed-char<br> -fsigned-char<br> -fno-unsigned-char<br> 　　这四个参数是对 char 类型进行设置,决定将 char 类型设置成 unsigned char(前<br> 　　两个参数)或者 signed char(后两个参数)</p><p>-include file<br> 　　包含某个代码,简单来说,就是便以某个文件,需要另一个文件的时候,就可以<br> 　　用它设定,功能就相当于在代码中使用#include<br> 　　例子用法:<br> 　　 gcc hello.c -include /root/pianopan.h<br> -imacros file<br> 　　将 file 文件的宏,扩展到 gcc/g++的输入文件,宏定义本身并不出现在输入文件<br> 　　中<br> -Dmacro<br> 　　相当于 C 语言中的#define macro<br> -Dmacro=defn<br> 　　相当于 C 语言中的#define macro=defn<br> -Umacro<br> 　　相当于 C 语言中的#undef macro<br> -undef<br> 　　取消对任何非标准宏的定义<br> -Idir<br> 　　在你是用#include&quot;file&quot;的时候,gcc/g++会先在当前目录查找你所制定的头<br> 　　文件,如果没有找到,他回到缺省的头文件目录找,如果使用-I 制定了目录,他<br> 　　回先在你所制定的目录查找,然后再按常规的顺序去找.<br> 　　对于#include,gcc/g++会到-I 制定的目录查找,查找不到,然后将到系<br> 　　统的缺省的头文件目录查找<br> -I-<br> 　　就是取消前一个参数的功能,所以一般在-Idir 之后使用<br> -idirafter dir<br> 　　在-I 的目录里面查找失败,讲到这个目录里面查找.<br> -iprefix prefix<br> -iwithprefix dir<br> 　　一般一起使用,当-I 的目录查找失败,会到 prefix+dir 下查找<br> -nostdinc<br> 　　使编译器不再系统缺省的头文件目录里面找头文件,一般和-I 联合使用,明确<br> 　　限定头文件的位置<br> -nostdin C++<br> 　　规定不在 g++指定的标准路经中搜索,但仍在其他路径中搜索,.此选项在创建<br> 　　 libg++库使用<br> -C<br> 　　在预处理的时候,不删除注释信息,一般和-E 使用,有时候分析程序，用这个很<br> 　　方便的<br> -M<br> 　　生成文件关联的信息。包含目标文件所依赖的所有源代码<br> 　　你可以用 gcc -M hello.c 来测试一下，很简单。<br> -MM<br> 　　和上面的那个一样，但是它将忽略由#include 造成的依赖关系。<br> -MD<br> 　　和-M 相同，但是输出将导入到.d 的文件里面<br> -MMD<br> 　　和-MM 相同，但是输出将导入到.d 的文件里面<br> -Wa,option<br> 　　此选项传递 option 给汇编程序;如果 option 中间有逗号,就将 option 分成多个选<br> 　　项,然后传递给会汇编程序<br> -Wl.option<br> 　　此选项传递 option 给连接程序;如果 option 中间有逗号,就将 option 分成多个选<br> 　　项,然后传递给会连接程序.<br> -llibrary<br> 　　制定编译的时候使用的库<br> 　　例子用法<br> 　　 gcc -lcurses hello.c<br> 　　使用 ncurses 库编译程序<br> -Ldir<br> 　　制定编译的时候，搜索库的路径。比如你自己的库，可以用它制定目录，不然<br> 　　编译器将只在标准库的目录找。这个 dir 就是目录的名称。<br> -O0<br> -O1<br> -O2<br> -O3<br> 　　编译器的优化选项的 4 个级别，-O0 表示没有优化,-O1 为缺省值，-O3 优化级别最<br> 　　高　　<br> -g<br> 　　只是编译器，在编译的时候，产生条是信息。<br> -gstabs<br> 　　此选项以 stabs 格式声称调试信息,但是不包括 gdb 调试信息.<br> -gstabs+<br> 　　此选项以 stabs 格式声称调试信息,并且包含仅供 gdb 使用的额外调试信息.<br> -ggdb<br> 　　此选项将尽可能的生成 gdb 的可以使用的调试信息.</p>',7),n=[i];function a(t,l){return b(),c("div",null,n)}const g=r(e,[["render",a],["__file","gcc.html.vue"]]);export{g as default};
