import{_ as a,X as p,Y as h,Z as e}from"./framework-418c825b.js";const r={},d=e('<h1 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构" aria-hidden="true">#</a> 数据结构</h1><p>主要分为物理结构和逻辑结构 物理结构是内存中实实在在的存储结构 逻辑结构是抽象概念，依赖物理结构</p><h2 id="物理结构" tabindex="-1"><a class="header-anchor" href="#物理结构" aria-hidden="true">#</a> 物理结构</h2><p>顺序存储结构：数组 链式存储结构：链表 数组和链表都是线性数据结构</p><h2 id="逻辑结构" tabindex="-1"><a class="header-anchor" href="#逻辑结构" aria-hidden="true">#</a> 逻辑结构</h2><p>线性结构：顺序表，栈，队列 非线性结构：树，图</p><h2 id="栈" tabindex="-1"><a class="header-anchor" href="#栈" aria-hidden="true">#</a> 栈</h2><p>First In Last Out 简称 FILO 可以用数组实现，也可以用链表实现</p><h2 id="队列" tabindex="-1"><a class="header-anchor" href="#队列" aria-hidden="true">#</a> 队列</h2><p>First In First Out 简称 FIFO 可以用数组实现，也可以用链表实现</p><h2 id="散列表" tabindex="-1"><a class="header-anchor" href="#散列表" aria-hidden="true">#</a> 散列表</h2><p>散列表也叫做哈希表(hash table) 本质上是个数组 会有哈希冲突，主要有两种开发寻址法(java ThreadLocal)，和链表法(java 集合类 HashMap) 链表法</p><h3 id="哈希函数" tabindex="-1"><a class="header-anchor" href="#哈希函数" aria-hidden="true">#</a> 哈希函数</h3><p>将 key 和数组下标转换，这个过程就是哈希函数</p><h3 id="扩容" tabindex="-1"><a class="header-anchor" href="#扩容" aria-hidden="true">#</a> 扩容</h3><p>基于数组实现，需要扩容 jdk8 会把 entry 的链表转换为红黑树这种结构，提升查找和插入效率</p><h2 id="树" tabindex="-1"><a class="header-anchor" href="#树" aria-hidden="true">#</a> 树</h2><p>root 根节点，leaf 叶子节点，parent 父节点，child 孩子节点，sibling 兄弟节点，树的最大层级称为高度或者深度</p><h3 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树" aria-hidden="true">#</a> 二叉树</h3><p>每个节点最多两个孩子节点 有两种特殊形式，一种是满二叉树，一种是完全二叉树</p><h4 id="满二叉树" tabindex="-1"><a class="header-anchor" href="#满二叉树" aria-hidden="true">#</a> 满二叉树</h4><p>都是完全的左右孩子节点</p><h4 id="完全二叉树" tabindex="-1"><a class="header-anchor" href="#完全二叉树" aria-hidden="true">#</a> 完全二叉树</h4><p>需要：1~h-1 层节点数最大(满二叉树)；h 层左连续</p><p>二叉树可以用数组和链式存储结构两种物理存储结构实现</p><p>稀疏的二叉树使用数组来实现是非常浪费空间的，不过二叉堆也就是一种特殊的完全二叉树最适合用数组来实现</p><h4 id="应用" tabindex="-1"><a class="header-anchor" href="#应用" aria-hidden="true">#</a> 应用</h4><p>查找：二叉查找树(二叉排序树) bst，查找的时间复杂度 O(logn)</p><p>左子树所有节点的值均小于根节点的值，右子树所有节点的值均大于根节点的值</p><h3 id="二叉树的遍历" tabindex="-1"><a class="header-anchor" href="#二叉树的遍历" aria-hidden="true">#</a> 二叉树的遍历</h3><p>二叉树是非线性结构，但是遍历本身是个线性操作，所以需要吧非线性关联节点转化成一个线性序列，所以才有了不同的遍历顺序</p><ol><li>前序遍历：根，左，右</li><li>中序遍历：左，根，右</li><li>后序遍历：左，右，根</li><li>层序遍历</li></ol><p>前三种是<strong>深度优先</strong>遍历，绝大多数是用<strong>递归</strong>来遍历，也可以使用栈来实现，因为递归和栈都具有回溯的特性。</p><p>最后一种是<strong>广度优先</strong>遍历，通过<strong>队列</strong>来实现，</p><p>二叉树的构建方法很多，可以把一个线性链表转换为非线性二叉树，链表节点的顺序就是二叉树前序遍历的顺序，链表空值代表左右孩子为空的情况</p><h3 id="二叉堆" tabindex="-1"><a class="header-anchor" href="#二叉堆" aria-hidden="true">#</a> 二叉堆</h3><p>本质是一种完全二叉树，分为两个类型：最大堆和最小堆</p><p>插入节点：插入到最后一个位置，进行上浮 O(logn)</p><p>删除节点：将最后一个节点临时补到原本删除的位置 O(logn)</p><p>构建二叉堆：把一个无序的完全二叉树调整为二叉堆，实际从 h-1 层开始调整 O(n)</p><p>二叉堆虽然是个完全二叉树，但是他的存储是顺序存储，而不是链式存储，就是使用数组实现的</p><p>二叉堆是实现<strong>堆排序</strong>及<strong>优先队列</strong>的基础</p><h3 id="优先队列" tabindex="-1"><a class="header-anchor" href="#优先队列" aria-hidden="true">#</a> 优先队列</h3><p>普通队列就是先进先出</p><p>最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队，最小队列同样</p><p>所以使用二叉堆来实现优先队列</p><h2 id="排序算法" tabindex="-1"><a class="header-anchor" href="#排序算法" aria-hidden="true">#</a> 排序算法</h2><p>时间复杂度为 O(n<sup>2</sup>)的排序</p><p>冒泡，选择，插入</p><p>冒泡主要交换</p><p>时间复杂度为 O(nlogn)的排序</p><p>希尔，快速，归并，堆</p><p>快排采用分治法，选一个基准元素，比大，比小各一边</p><p>基数排序，桶排序，归并排序</p><h3 id="冒泡算法" tabindex="-1"><a class="header-anchor" href="#冒泡算法" aria-hidden="true">#</a> 冒泡算法</h3><p>是稳定排序（相同元素，位置是否发生变化）</p><p>可以优化一：记录一个变量是否有交换元素，没有说明顺序已经 ok</p><p>可以优化二：记录一个变量标记最后交换的位置，这个未知后面就都是最终有序的，每轮就不需要去比较后面有序的元素了</p><p>鸡尾酒排序：冒泡的升级版，先左边开始冒泡，然后右边开始冒泡，这样中间部分有序的就不需要冒泡了，减少轮数（鸡尾酒排序已经使用了优化一了，可以在加上优化二，效果更加好）</p><h3 id="选择排序" tabindex="-1"><a class="header-anchor" href="#选择排序" aria-hidden="true">#</a> 选择排序</h3><p>不稳定排序</p><p>每次取一个剩下最大（小）的元素放到一边，和插入排序相反</p><p>两边，一边有序，一边无序，无序的一边每次取一个最大（小）的元素放到有序的一边</p><h3 id="插入排序" tabindex="-1"><a class="header-anchor" href="#插入排序" aria-hidden="true">#</a> 插入排序</h3><p>稳定排序</p><p>每次取一个元素放到已经排好序的组里进行一轮比较排序</p><p>两边，一边有序，一边无序，无序的一边每次取一个的元素放到有序的一边，和有序的进行重新排序</p><p>如果初始有序程度高，那么插入排序就越快，选择排序则和初始顺序无关</p><h3 id="希尔排序" tabindex="-1"><a class="header-anchor" href="#希尔排序" aria-hidden="true">#</a> 希尔排序</h3><p>不稳定排序</p><p>插入排序的升级版，gap1=len/2,gap2=gap1/2,...,1，每轮相连 gap 个做插入排序</p><h3 id="快速排序算法" tabindex="-1"><a class="header-anchor" href="#快速排序算法" aria-hidden="true">#</a> 快速排序算法</h3><p>分治法，每一轮挑选一个基准元素，让比它大的移到一边，比它小移到另一边，把数列拆成两个部分</p><p>平均时间复杂度 O(nlogn)，不稳定排序，最坏的时间复杂度是 O(n<sup>2</sup>)</p><p>双边循环法：right，left 从两边向中间</p><p>单边循环法：mark 作为一部小和一部分大的边界</p><p>都是递归去实现</p><p>绝大多数的递归逻辑，都可以用栈的方式替代</p><h3 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序" aria-hidden="true">#</a> 归并排序</h3><h3 id="堆排序" tabindex="-1"><a class="header-anchor" href="#堆排序" aria-hidden="true">#</a> 堆排序</h3><p>因为堆顶是个最小大元素，每次获取堆顶元素都是按照大小依次排序的</p><p>平均时间复杂度和最坏空间复杂度都是 O(nlogn)</p><p>新增，删除堆顶元素的时间复杂度是 O(logn)</p><p>构建大小堆的时间负责度是 O(n)</p><p>推导：S=1×2<sup>h-1</sup>+2×2<sup>h-2</sup>+3×2<sup>h-3</sup>+...+(h-1)2<sup>1</sup>+h×2<sup>0</sup></p><p>2S=1×2<sup>h</sup>+2×2<sup>h-1</sup>+3×2<sup>h-2</sup>+...+h×2<sup>1</sup></p><p>2S-S=2<sup>h</sup>+2<sup>h-1</sup>+...+2<sup>1</sup>+2<sup>0</sup>-2<sup>0</sup>-h×2<sup>0</sup></p><p>S=2<sup>h+1</sup>-1-1-h=2<sup>h+1</sup>-2-h</p><p>h=logn</p><p>S=2n-2-logn=O(n)</p><p>堆排序两个过程</p><p>1.构建堆 O(n)</p><p>2.逐个取出顶元素 (n-1)×logn</p><p>O(n)+(n-1)logn=O(nlogn)</p><p>堆排序和快速排序都是不稳定的，平均时间复杂度都是 O(nlogn)</p><p>快速排序最换时间复杂度是 n<sup>2</sup>,而堆排序的最坏时间复杂度稳定在 O(nlogn)</p><h3 id="基数排序" tabindex="-1"><a class="header-anchor" href="#基数排序" aria-hidden="true">#</a> 基数排序</h3><h3 id="计数排序" tabindex="-1"><a class="header-anchor" href="#计数排序" aria-hidden="true">#</a> 计数排序</h3><h3 id="桶排序" tabindex="-1"><a class="header-anchor" href="#桶排序" aria-hidden="true">#</a> 桶排序</h3><p>一种线性时间排序算法</p>',100),n=[d];function i(s,t){return p(),h("div",null,n)}const u=a(r,[["render",i],["__file","大纲.html.vue"]]);export{u as default};
