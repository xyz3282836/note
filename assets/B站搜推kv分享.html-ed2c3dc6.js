import{_ as a,W as e,X as h,a0 as r}from"./framework-1046fca1.js";const d="/assets/image-20221024181314427-4f2f783a.png",i={},t=r('<h1 id="b站kv搜索分享" tabindex="-1"><a class="header-anchor" href="#b站kv搜索分享" aria-hidden="true">#</a> b站kv搜索分享</h1><h3 id="场景" tabindex="-1"><a class="header-anchor" href="#场景" aria-hidden="true">#</a> 场景</h3><p>Data intensity ：亿级稿件选top-N</p><p>latency sensitive：500ms</p><p>OLAP：列式存储，搜推场景</p><p>OLTP：行式存储，主站场景</p><h3 id="kv分类" tabindex="-1"><a class="header-anchor" href="#kv分类" aria-hidden="true">#</a> kv分类</h3><p>embedded in memory kv: 语言提供的map存储</p><p>in memory kv srever: memcached, redis</p><p>embedded kv database: leveldb, rocksdb(基于lsmtree)</p><p>distributed kv database: taishan, TiKV</p><p>complicated data-model: BigTable, MongoDB, Cassandra, Dynamo</p><p>data structure: B-tree, LSM-tree, hash-map</p><h3 id="embedded-in-memory-kv" tabindex="-1"><a class="header-anchor" href="#embedded-in-memory-kv" aria-hidden="true">#</a> Embedded in memory KV</h3><p>业务场景：每秒查询20亿个key，20 kps，随机点读，random point read，10-20G，10w kps update</p><p>高频访问，存储不大，增量远远小于存量</p><p>选型是内存数据库kv，数据结构hashmap</p><p>对于高频，随机，点查场景有很多数据结构可以选择，skin-list，sorted-array，hash-map，btree，rbtree</p><p>hash-map多种实现（核心问题是解决key冲突）：open-addressing，separate chaining，perfect-hash，cuckoo-hash（google 布谷鸟hash，理论复杂度最坏是O(1)，实际生成环境不理想，建立hash表无限循环，建立索引失败，依赖两个hash函数解决冲突；另外查询冲突的key离的比较远，效率就低了，cache 命中率比较低，不友好）</p><p>影响hash的几个因素：hash函数，更少的指令计算更加均匀的hash；计算hash 分桶的过程（取模太慢），小的数据规模可以使用位操作，大的数据规模可以采用高32位*bucket再去取高32位作为bucket的index</p><h4 id="几种现在比较高效的hash结构" tabindex="-1"><a class="header-anchor" href="#几种现在比较高效的hash结构" aria-hidden="true">#</a> 几种现在比较高效的hash结构</h4><h5 id="robin-hood-hash" tabindex="-1"><a class="header-anchor" href="#robin-hood-hash" aria-hidden="true">#</a> robin-hood hash</h5><h5 id="flatmap" tabindex="-1"><a class="header-anchor" href="#flatmap" aria-hidden="true">#</a> flatmap</h5><h5 id="flat-hash-map-f14" tabindex="-1"><a class="header-anchor" href="#flat-hash-map-f14" aria-hidden="true">#</a> flat hash map（f14）</h5><p>并不适合当前业务场景，90%命中率，value是指针int64地址</p><h5 id="neighbor-hash" tabindex="-1"><a class="header-anchor" href="#neighbor-hash" aria-hidden="true">#</a> neighbor hash</h5><p>采用open-address，冲突放在最近，提高cache命中率</p><p>x64架构下，64bit地址只是使用了48位，用剩下的16bit来存放冲突的下个节点</p><h5 id="epoch-protection-framework" tabindex="-1"><a class="header-anchor" href="#epoch-protection-framework" aria-hidden="true">#</a> epoch protection framework</h5><figure><img src="'+d+'" alt="image-20221024181314427" tabindex="0" loading="lazy"><figcaption>image-20221024181314427</figcaption></figure><p>一次批量操作，只原子操作一次</p><h3 id="kfc" tabindex="-1"><a class="header-anchor" href="#kfc" aria-hidden="true">#</a> KFC</h3><p>remote kv store</p><p>参考 google mesa，apache doris</p><p>batch update 吞吐大</p><h5 id="nvme-backend" tabindex="-1"><a class="header-anchor" href="#nvme-backend" aria-hidden="true">#</a> nvme backend</h5><p>key存放在内存，value存放nvme；复用48bit value，1bit作为标识是否是cache还是nvme</p><h3 id="kv-in-parameter-server" tabindex="-1"><a class="header-anchor" href="#kv-in-parameter-server" aria-hidden="true">#</a> KV in parameter Server</h3>',38),n=[t];function s(p,o){return e(),h("div",null,n)}const m=a(i,[["render",s],["__file","B站搜推kv分享.html.vue"]]);export{m as default};
