const t=JSON.parse('{"key":"v-41db700c","path":"/tech/database/lock.html","title":"锁","lang":"zh-CN","frontmatter":{"description":"锁 for update 仅适用于 InnoDB，并且必须开启事务，在 begin 与 commit 之间才生效。 要测试 for update 的锁表情况，可以利用 MySQL 的 Command Mode，开启二个视窗来做测试。 for update 的疑问点: 当开启一个事务进行 for update 的时候，另一个事务也有 for update 的时候会一直等着，直到第一个事务结束吗？ 答：会的。除非第一个事务 commit 或者 rollback 或者断开连接，第二个事务会立马拿到锁进行后面操作。不过也可以设置锁等待超时参数 innodb_lock_wait_timeout 来解决。 如果没查到记录会加锁吗？ 答：会的。有主键/索引产生间隙锁，无主键/索引产生表锁表级锁。 for update 和 for update nowait 区别（前者阻塞其他事务，后者拒绝其他事务） for update 锁住表或者锁住行，只允许当前事务进行操作（读写），其他事务被阻塞，直到当前事务提交或者回滚，被阻塞的事务自动执行 for update nowait 锁住表或者锁住行，只允许当前事务进行操作（读写），其他事务被拒绝，事务占据的 statement 连接也会被断开","head":[["meta",{"property":"og:url","content":"https://www.ruizhou.cf/tech/database/lock.html"}],["meta",{"property":"og:site_name","content":"rz文档"}],["meta",{"property":"og:title","content":"锁"}],["meta",{"property":"og:description","content":"锁 for update 仅适用于 InnoDB，并且必须开启事务，在 begin 与 commit 之间才生效。 要测试 for update 的锁表情况，可以利用 MySQL 的 Command Mode，开启二个视窗来做测试。 for update 的疑问点: 当开启一个事务进行 for update 的时候，另一个事务也有 for update 的时候会一直等着，直到第一个事务结束吗？ 答：会的。除非第一个事务 commit 或者 rollback 或者断开连接，第二个事务会立马拿到锁进行后面操作。不过也可以设置锁等待超时参数 innodb_lock_wait_timeout 来解决。 如果没查到记录会加锁吗？ 答：会的。有主键/索引产生间隙锁，无主键/索引产生表锁表级锁。 for update 和 for update nowait 区别（前者阻塞其他事务，后者拒绝其他事务） for update 锁住表或者锁住行，只允许当前事务进行操作（读写），其他事务被阻塞，直到当前事务提交或者回滚，被阻塞的事务自动执行 for update nowait 锁住表或者锁住行，只允许当前事务进行操作（读写），其他事务被拒绝，事务占据的 statement 连接也会被断开"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-11T16:47:37.000Z"}],["meta",{"property":"article:author","content":"rz"}],["meta",{"property":"article:modified_time","content":"2023-03-11T16:47:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"锁\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-11T16:47:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"rz\\",\\"url\\":\\"https://github.com/xyz3282836/monodoc\\"}]}"]]},"headers":[],"git":{"createdTime":1678553257000,"updatedTime":1678553257000,"contributors":[{"name":"liuruizhou","email":"liuruizhou@bilibili.com","commits":1}]},"readingTime":{"minutes":1.04,"words":313},"filePathRelative":"tech/database/lock.md","localizedDate":"2023年3月12日","excerpt":"<h1> 锁</h1>\\n<ul>\\n<li>for update 仅适用于 InnoDB，并且必须开启事务，在 begin 与 commit 之间才生效。</li>\\n<li>要测试 for update 的锁表情况，可以利用 MySQL 的 Command Mode，开启二个视窗来做测试。<br>\\n<strong>for update 的疑问点:</strong></li>\\n<li>当开启一个事务进行 for update 的时候，另一个事务也有 for update 的时候会一直等着，直到第一个事务结束吗？<br>\\n答：会的。除非第一个事务 commit 或者 rollback 或者断开连接，第二个事务会立马拿到锁进行后面操作。不过也可以设置锁等待超时参数 innodb_lock_wait_timeout 来解决。</li>\\n<li>如果没查到记录会加锁吗？<br>\\n答：会的。有主键/索引产生间隙锁，无主键/索引产生表锁表级锁。</li>\\n<li>for update 和 for update nowait 区别（前者阻塞其他事务，后者拒绝其他事务）<br>\\nfor update 锁住表或者锁住行，只允许当前事务进行操作（读写），其他事务被阻塞，直到当前事务提交或者回滚，被阻塞的事务自动执行<br>\\nfor update nowait 锁住表或者锁住行，只允许当前事务进行操作（读写），其他事务被拒绝，事务占据的 statement 连接也会被断开</li>\\n</ul>","autoDesc":true}');export{t as data};
