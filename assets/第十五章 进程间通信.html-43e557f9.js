import{_ as s,X as n,Y as a,Z as e}from"./framework-5a8052d6.js";const p={},t=e(`<h1 id="第十五章-进程间通信" tabindex="-1"><a class="header-anchor" href="#第十五章-进程间通信" aria-hidden="true">#</a> 第十五章 进程间通信</h1><p>半双工管道、全双工管道、FIFO</p><p>UDS，管道</p><p>同一台主机的两个进程之间的 IPC，套接字和 STREAMS 是仅有的支持不同主机上两个进程之间 IPC 的两种形式</p><p>本章讨论经典的 IPC：管道、FIFO、消息队列、信号量 以及共享存储</p><h2 id="管道" tabindex="-1"><a class="header-anchor" href="#管道" aria-hidden="true">#</a> 管道</h2><p>局限性：历史上半双工，数据单向；在公共祖先的两个进程间使用，通常父子进程使用</p><p>FIFO 没有第二种限制，uds 没有这两种限制</p><p>每当在管道中键入一个命令序列， 让 shell 执行时，shell 都会为每一条命令单独创建一个进程，然后用管道将前一条命令进程的标 准输出与后一条命令的标准输入相连接</p><p>管道是通过调用 pipe 函数创建的</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>读 <span class="token operator">&lt;</span><span class="token operator">-</span> fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>写
fd<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>的输出是fd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>的输入
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>单个进程中的管道几乎没有任何用处</p><p>管道连接着一个写端的进程，一个读端的进程；读一个写端的管道，写一个读端的管道</p><h2 id="popen-和-pcloose" tabindex="-1"><a class="header-anchor" href="#popen-和-pcloose" aria-hidden="true">#</a> popen 和 pcloose</h2><p>创建一个管道，fork 一个子进程，关闭未使用的管道端，执行一个 shell 运行命令，然后等待命令终止。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
FILE <span class="token operator">*</span><span class="token function">popen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cmdstring<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">pclose</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>popen 的 r 模式： 子进程 cmd 的标准输出连接到父进程的文件指针</p><p>popen 的 w 模式：父进程的文件指针连接到子进程的 cmd 的标准输入</p><h2 id="协同进程" tabindex="-1"><a class="header-anchor" href="#协同进程" aria-hidden="true">#</a> 协同进程</h2><p>当一个过滤程序既产生某个过滤程序的输入，又读取该过滤程序的输出时，它就变成了协同进程</p><p>两个 pipe 实现可以双工</p><h2 id="fifo" tabindex="-1"><a class="header-anchor" href="#fifo" aria-hidden="true">#</a> FIFO</h2><p>前面用的其实是未命名管道，只能两个相关进程使用，如父子进程，而 FIFO 是命名管道，不相关进程也能通信</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span><span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">mkfifoat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span><span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>mode 与 open 的 mode 一样</p><p>mkfifoat 函数可以被用来在 fd 文件描述符表 示的目录相关的位置创建一个 FIFO</p><p>FIFO 的用途：</p><ol><li>shell 命令使用 FIFO 将数据从一条管道传送到另一条时，无需创建中间临时文件。</li><li>客户进程-服务器进程应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程二者之 间传递数据</li></ol><h2 id="xsi-ipc" tabindex="-1"><a class="header-anchor" href="#xsi-ipc" aria-hidden="true">#</a> XSI IPC</h2><p>有 3 种称作 XSI IPC 的 IPC：消息队列，信号量，共享存储器</p><blockquote><p>XSI IPC 函数是紧密地基于 System V 的 IPC 函数的</p></blockquote><h3 id="标识符和键" tabindex="-1"><a class="header-anchor" href="#标识符和键" aria-hidden="true">#</a> 标识符和键</h3><p>与文件描述符不同，IPC 标识符不是小的整数。当一个 IPC 结构被创建，然后又被 删除时，与这种结构相关的标识符连续加 1，直至达到一个整型数的最大正值，然后又回转到 0</p><p>有多种方法使客户进程和服务器进程在同一 IPC 结构上汇聚</p><p>1，2，3；1，2 都有明显缺点，3 是基于 2，客服 2 的缺点</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h&gt;</span></span>
<span class="token class-name">key_t</span> <span class="token function">ftok</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>客户进程和服务器进程认同一个路径名和项目 ID（项目 ID 是 0 ～ 255 之 接着，调用函数 ftok 将这两个值变换为一个键。</p><h3 id="权限结构" tabindex="-1"><a class="header-anchor" href="#权限结构" aria-hidden="true">#</a> 权限结构</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span><span class="token punctuation">{</span>
    <span class="token class-name">uid_t</span> uid<span class="token punctuation">;</span>
    <span class="token class-name">gid_t</span> gid<span class="token punctuation">;</span>
    <span class="token class-name">uid_t</span> cuid<span class="token punctuation">;</span>
    <span class="token class-name">gid_t</span> cgid<span class="token punctuation">;</span>
    <span class="token class-name">mode_t</span> mode<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>权限</th><th>位</th></tr></thead><tbody><tr><td>用户读</td><td>0400</td></tr><tr><td>用户写（更改）</td><td>0200</td></tr><tr><td>组读</td><td>0040</td></tr><tr><td>组写（更改）</td><td>0020</td></tr><tr><td>其他读</td><td>0004</td></tr><tr><td>其他写（更改）</td><td>0002</td></tr></tbody></table><h3 id="结构限制" tabindex="-1"><a class="header-anchor" href="#结构限制" aria-hidden="true">#</a> 结构限制</h3><h3 id="优缺点" tabindex="-1"><a class="header-anchor" href="#优缺点" aria-hidden="true">#</a> 优缺点</h3><p>管道和 FIFO 在最后一个引用进程终止后，会删除数据，但是 3 中 IPC 不会</p><p>这些 IPC 结构在文件系统中<strong>没有名字</strong>，需要内核增加十几个全新的系统调用，如 msgget，semget，shmget</p><h2 id="消息队列" tabindex="-1"><a class="header-anchor" href="#消息队列" aria-hidden="true">#</a> 消息队列</h2><p>每个消息都由 3 部分组成：一个正的长整型类型的字段、一个非负的长度 （nbytes）以及实际数据字节数（对应于长度）。</p><p>消息总是放在队列尾端</p><p>消息队列是消息的链接表，存储在内核中，由消息队列标识符标识</p><p>msgget 用于创建一个新队列或打开一个现有队列</p><p>msgsnd 将新消息添加到队列尾端</p><p>msgrcv 用于从队列中取消息</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">msgget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span><span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">msgget</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0x123</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IPC_CREAT <span class="token operator">|</span> <span class="token number">0666</span><span class="token punctuation">)</span>
<span class="token keyword">int</span> <span class="token function">msgctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> msgid<span class="token punctuation">,</span><span class="token keyword">int</span> cmd<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">msgid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
每个队列都有一个msgid_ds
<span class="token keyword">struct</span> <span class="token class-name">msgid_ds</span><span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span> msg_perm<span class="token punctuation">;</span>
	<span class="token class-name">msggnum_t</span> msg_gnum<span class="token punctuation">;</span>
	<span class="token class-name">msglen_t</span> msg_qbytes<span class="token punctuation">;</span>
	<span class="token class-name">pid_t</span> msg_lspid<span class="token punctuation">;</span>
	<span class="token class-name">pid_t</span> msg_lrpid<span class="token punctuation">;</span>
	<span class="token class-name">time_t</span> msg_stime<span class="token punctuation">;</span>
	<span class="token class-name">time_t</span> msg_rtime<span class="token punctuation">;</span>
	<span class="token class-name">time_t</span> msg_ctime<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>msgctl 函数对队列执行多种操作（类似的还有 semctl，shmctl）</p><p>cmd:也可用于信号量和共享存储</p><p>IPC_STAT 取此队列的 msqid_ds 结构，并将它存放在 buf 指向的结构中</p><p>IPC_SET 将字段 msg_perm.uid、msg_perm.gid、msg_perm.mode 和 msg_qbytes 从 buf 指向的结构复制到与这个队列相关的 msqid_ds 结构中</p><p>IPC_RMID 从系统中删除该消息队列以及仍在该队列中的所有数据。这种删除立即生效</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">msgsnd</span><span class="token punctuation">(</span><span class="token keyword">int</span> msgid<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token class-name">size_t</span> nbytes<span class="token punctuation">,</span><span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
ptr 就是一个指向 mymesg 结构的指针
<span class="token keyword">struct</span> <span class="token class-name">mymesg</span><span class="token punctuation">{</span>
    <span class="token keyword">long</span> mtype<span class="token punctuation">;</span>
    <span class="token keyword">char</span> mtext<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对删除消息队列的处理不是很完善，没有维护引用计数器</p><p>ptr 参数指向一个长整型数，它包含了正的整型消息类型，其后紧接着的是消息数据（若 nbytes 是 0，则无消息数据） 参数 flag 的值可以指定为 IPC_NOWAIT。这类似于文件 I/O 的非阻塞 I/O 标志</p><p>当 msgsnd 返回成功时，消息队列相关的 msqid_ds 结构会随之更新，表明调用的进程 ID （msg_lspid）、调用的时间（msg_stime）以及队列中新增的消息（msg_qnum）</p><p>msgrcv 从队列中取用消息</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h&gt;</span></span>
<span class="token class-name">ssize_t</span> <span class="token function">msgrcv</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> nbytes<span class="token punctuation">,</span> <span class="token keyword">long</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>flag 中设置了 MSG_NOERROR 位，则该消息会被截断；flag 值指定为 IPC_NOWAIT，使操作不阻塞</p><p>参数 type 可以指定想要哪一种消息</p><p>msgrcv 成功执行时，内核会更新与该消息队列相关联的 msgid_ds 结构，以指示调用者的进程 ID（msg_lrpid）和调用时间（msg_rtime），并指示队列中的消息数减少了 1 个（msg_qnum）</p><h2 id="消息队列与全双工管道的时间比较" tabindex="-1"><a class="header-anchor" href="#消息队列与全双工管道的时间比较" aria-hidden="true">#</a> 消息队列与全双工管道的时间比较</h2><p>客户进程和服务器进程之间的双向数据流:</p><p>可以使用消息队列或全双工管道</p><p>可以使全双工管道可用，而某些平台通过 pipe 函数提供全双工管道</p><p>考虑到使用消息队列时遇到的问题（见 15.6.4 节），我们得出的 结论是，在新的应用程序中不应当再使用它们</p><h2 id="信号量" tabindex="-1"><a class="header-anchor" href="#信号量" aria-hidden="true">#</a> 信号量</h2><p>信号量与已经介绍过的 IPC 机构（管道、FIFO 以及消息列队）不同。它是一个计数器，用 于为多个进程提供对共享数据对象的访问。</p><p>若此信号量的值为正，则进程可以使用该资源。在这种情况下，进程会将信号量值减 1， 表示它使用了一个资源单位</p><p>否则，若此信号量的值为 0，则进程进入休眠状态，直至信号量值大于 0。进程被唤醒 后</p><p>当进程不再使用由一个信号量控制的共享资源时，该信号量值增 1。如果有进程正在休眠等 待此信号量，则唤醒它们</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>内核为每个信号量集合维护着一个 semid_ds 结构
<span class="token keyword">struct</span> <span class="token class-name">semid_ds</span><span class="token punctuation">{</span>
	<span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span> sem_perm<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> sem_nsems<span class="token punctuation">;</span>
	<span class="token class-name">time_t</span> sem_otime<span class="token punctuation">;</span>
	<span class="token class-name">time_t</span> sem_ctime<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
每个信号量由一个无名结构表示
<span class="token keyword">struct</span><span class="token punctuation">{</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> semval<span class="token punctuation">;</span>
	<span class="token class-name">pid_t</span> ssempid<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> semncnt<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> semzcnt<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用函数 semget 来获得一个信号量 ID</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sem.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">semget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> nsems<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">semctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">int</span> semnum<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* union semun arg */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>初始化 ipc_perm 结构。该结构中的 mode 成员被设置为 flag 中的 相应权限位</p><p>nsems 是该集合中的信号量数。如果是创建新集合（一般在服务器进程中），则必须指定 nsems。 如果是引用现有集合（一个客户进程），则将 nsems 指定为 0。</p><p>cmd：10 种</p><p>函数 semop 自动执行信号量集合上的操作数组</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sem.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">semop</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> semoparray<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span> nops<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>参数 semoparray 是一个指针，它指向一个由 sembuf 结构表示的信号量操作数组</p><p>参数 nops 规定该数组中操作的数量（元素数）。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">sembuf</span><span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> sem_num<span class="token punctuation">;</span>
    <span class="token keyword">short</span> sem_op<span class="token punctuation">;</span><span class="token comment">//对集合中每个成员的操作由相应的 sem_op 值规定</span>
    <span class="token keyword">short</span> sem_flg<span class="token punctuation">;</span><span class="token comment">//IPC_NOWAIT, SEM_UNDO</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>sem_op 为正值，这对应于进程释放的占用的资源数，需要加到信号量的值上；如果指定了 undo 标志，则也从该进程的此信号量调整值中减去 sem_op</p><p>sem_op 为负值，信号量的值大于等于 sem_op 的绝对值，从信号量值中减去 sem_op 的绝对值；如果指定了 undo 标志，则 sem_op 的绝对值也 加到该进程的此信号量调整值上</p><p>正负两者操作其实是一个道理</p><p>sem_op 为 0，这表示调用进程希望等待到该信号量值变成 0</p><h3 id="exit-时的信号量调整" tabindex="-1"><a class="header-anchor" href="#exit-时的信号量调整" aria-hidden="true">#</a> exit 时的信号量调整</h3><p>正如前面提到的，如果在进程终止时，它占用了经由信号量分配的资源，那么就会成为一个 问题。</p><h2 id="信号量、记录锁和互斥量的时间比较" tabindex="-1"><a class="header-anchor" href="#信号量、记录锁和互斥量的时间比较" aria-hidden="true">#</a> 信号量、记录锁和互斥量的时间比较</h2><h2 id="共享存储" tabindex="-1"><a class="header-anchor" href="#共享存储" aria-hidden="true">#</a> 共享存储</h2><p>信号量用于同步共享存储访问</p><p>在多个进程将同一个文件映射到它们的地址空间 的时候。</p><p>XSI 共享存储和内存映射的文件的不同之处在于，前者没有相关的文件。</p><p>XSI 共享存储 段是内存的匿名段</p><p>内核为每个共享存储段维护着一个结构</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span><span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span> shm_perm<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> shm_segsz<span class="token punctuation">;</span>
    <span class="token class-name">pid_t</span> shm_lpid<span class="token punctuation">;</span>
    <span class="token class-name">pid_t</span> shm_cpid<span class="token punctuation">;</span>
    <span class="token class-name">shmatt_t</span> shm_nattch<span class="token punctuation">;</span>
    <span class="token class-name">time_t</span> shm_atime<span class="token punctuation">;</span>
    <span class="token class-name">time_t</span> shm_dtime<span class="token punctuation">;</span>
    <span class="token class-name">time_t</span> shm_ctime<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用的第一个函数通常是 shmget，它获得一个共享存储标识符</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>mode 按 flag 中的相应权限位 设置</p><p>shmctl 函数对共享存储段执行多种操作</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">shmctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Cmd：5 种命令</p><p>一旦创建了一个共享存储段，进程就可调用 shmat 将其连接到它的地址空间中</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h&gt;</span></span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">shmdt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 addr 为 0，则此段连接到由内核选择的第一个可用地址上。这是推荐的使用方式</p><p>flag 中指定了 SHM_RDONLY 位，则以只读方式连接此段，否则以读写方式连接此段</p><p>shmat 的返回值是该段所连接的实际地址，如果出错则返回 −1；成功，内核将使与该共享存储段相关的 shmid_ds 结构中的 shm_nattch 计数器值加 1</p><p>共享存储段紧靠在 栈之下</p><h2 id="posix-信号量" tabindex="-1"><a class="header-anchor" href="#posix-信号量" aria-hidden="true">#</a> POSIX 信号量</h2><p>POSIX 信号量接口意在解决 XSI 信号量接口的几个缺陷：</p><ol><li>更高性能的实现</li><li>没有信号量集，更加简单</li><li>操作能继续正常工作直到该信号量的最后一次引用被释放；XSI 信号量被删除时，使用这个 信号量标识符的操作会失败</li></ol><p>POSIX 信号量有两种形式：命名的和未命名的</p><p>调用 sem_open 函数来创建一个新的命名信号量或者使用一个现有信号量</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>
<span class="token class-name">sem_t</span> <span class="token operator">*</span><span class="token function">sem_open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> <span class="token keyword">int</span> oflag<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* mode_t mode,unsigned int value */</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_close</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当使用一个现有的命名信号量时，我们仅仅指定两个参数：信号量的名字和 oflag 参数的 0 值 当这个 oflag 参数有 O_CREAT 标志集时，如果命名信号量不存在，则创建一个新的。如果它 已经存在，则会被使用，但是不会有额外的初始化发生</p><p>当我们指定 O_CREAT 标志时，需要提供两个额外的参数。mode 参数指定谁可以访问信号量。 mode 的取值和打开文件的权限位相同</p><p>在创建信号量时，value 参数用来指定信号量的初始值。它的取值是 0 ～ SEM_VALUE_MAX</p><p>如果我们想确保创建的是信号量，可以设置 oflag 参数为 O_CREAT|O_EXCL。如果信号量已 经存在，会导致 sem_open 失败</p><p>可以使用 sem_unlink 函数来销毁一个命名信号量</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">sem_unlink</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>sem_unlink 函数删除信号量的名字。如果没有打开的信号量引用，则该信号量会被销毁。 否则，销毁将延迟到最后一个打开的引用关闭</p><p>可以使用 sem_wait 或者 sem_trywait 函数来实现信号量的减 1 操作</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">sem_trywait</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_wait</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_timedwait</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>restrict sem<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>restrict tsptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 sem_wait 函数时，如果信号量计数是 0 就会发生阻塞。直到成功使信号量减 1 或者被 信号中断时才返回</p><p>可以调用 sem_post 函数使信号量值增 1</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">sem_post</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们想在单个进程中使用 POSIX 信号量时，使用未命名信号量更容易。这仅仅改变创建和 销毁信号量的方式。可以调用 sem_init 函数来创建一个未命名的信号量。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_destroy</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">sem_getvalue</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>restrict sem<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>restrict valp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>pshared 参数表明是否在多个进程中使用信号量。如果是，将其设置成一个非 0 值。value 参 数指定了信号量的初始值。</p><p>如果要在两个进程之间使用信号量，需要确保 sem 参数指向两个进程之间共享的内存范围</p><p>对未命名信号量的使用已经完成时，可以调用 sem_destroy 函数丢弃它</p><p>调用 sem_destroy 后，不能再使用任何带有 sem 的信号量函数，除非通过调用 sem_init 重新初始化它</p><p>sem_getvalue 函数可以用来检索信号量值</p><h2 id="客户进程-服务器进程属性" tabindex="-1"><a class="header-anchor" href="#客户进程-服务器进程属性" aria-hidden="true">#</a> 客户进程-服务器进程属性</h2>`,139),c=[t];function o(i,l){return n(),a("div",null,c)}const u=s(p,[["render",o],["__file","第十五章 进程间通信.html.vue"]]);export{u as default};
