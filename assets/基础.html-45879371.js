import{_ as e,W as t,X as p,Z as n,$ as i,a0 as o,Y as s,C as c}from"./framework-7d39e0da.js";const l="/assets/函数栈帧空间-b08b32b8.png",u="/assets/goroutine-stack-1367aa41.png",r={},d=s('<h1 id="基础" tabindex="-1"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h1><p>slice，map，channel 都是引用类型</p><p>array 是值类型，区分 slice</p><p>slice 触发扩容，新的赋值的 slice 的 data 会指向新的底层数组</p><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h2><p>闭包是为了减少全局变量，所以闭包引用全局变量不是好的编程方式。</p><p>闭包这种隐秘的共享变量的方式带来的坏处是不够直接，不够清晰，除非是非常有价值的地方，一般不建议使用闭包。</p><h2 id="go-函数的内部实现" tabindex="-1"><a class="header-anchor" href="#go-函数的内部实现" aria-hidden="true">#</a> go 函数的内部实现</h2><p>go 函数使用的是 caller-save 的模式，即由调用者负责保存寄存器。</p><p>SB static base pointer 静态基址寄存器，它和全局符号一起表示全局变量的地址。</p><p>FP frame pointer 栈帧寄存器，该寄存器指向当前函数调用栈帧的<strong>栈底</strong>位置</p><p>PC program counter 程序计数器，存放下一条指令的执行地址，很少直接操作该寄存器，一般是 call，ret 等指令隐式的操作</p><p>SP stack pointer <strong>栈顶</strong>寄存器，一般在函数调用前由主函数设置 SP 的值对栈空间进行分配或回收</p><p>Go 语言的汇编代码中栈寄存器解释的非常模糊，我们大概只要知道两个寄存器 BP 和 SP 的作用就可以了</p><p>BP: 栈底指针，<strong>基准指针寄存器</strong>，维护当前栈帧的基准地址，以便用来索引变量和参数，就像一个锚点一样，在其它架构中它等价于帧指针<code>FP</code>，只是在 x86 架构下，变量和参数都可以通过 SP 来索引</p><p>SP：栈顶指针，<strong>栈指针寄存器</strong>，总是指向栈顶</p><p><strong>栈的增长方向永远是从底到顶，所以栈顶和栈底不是上下决定，而是有入栈方向决定</strong></p><p>![](./../img/32867-Linux_UNIX 系统编程手册（上、下册），第 125 页.png)</p>',18),k={href:"https://zhuanlan.zhihu.com/p/447224382",target:"_blank",rel:"noopener noreferrer"},v=s(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>// <span class="token parameter variable">-S</span> 产生汇编代码
// <span class="token parameter variable">-N</span> 禁用优化
// <span class="token parameter variable">-l</span> 禁用内联
<span class="token assign-left variable">GOOS</span><span class="token operator">=</span>liunx <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>amd64 go tool compile <span class="token parameter variable">-l</span> <span class="token parameter variable">-N</span> <span class="token parameter variable">-S</span> main.go <span class="token operator">&gt;</span> main.s


// go:noinline 无所谓，但是一定要有 <span class="token parameter variable">-l</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基本指令</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SUBQ $0x18, SP // 对SP做减法，为函数分配函数栈帧
ADDQ $0x18, SP // 对SP做加法，清楚函数栈帧

MOVB $1,DI
MOVW $0x10,BX
MOVD $1,DX
MOVQ $-10,AX
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="go-类型系统" tabindex="-1"><a class="header-anchor" href="#go-类型系统" aria-hidden="true">#</a> Go 类型系统</h2><h3 id="命名类型" tabindex="-1"><a class="header-anchor" href="#命名类型" aria-hidden="true">#</a> 命名类型</h3><h4 id="_1-自定义型-user-defined-type" tabindex="-1"><a class="header-anchor" href="#_1-自定义型-user-defined-type" aria-hidden="true">#</a> 1.自定义型 User-defined type</h4>',8),m=n("p",{"css-module":"."},"type Person struct",-1),b=s(`<p>type myint int</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> MyInt <span class="token builtin">int</span><span class="token comment">// 使用type</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>m MyInt<span class="token punctuation">)</span> <span class="token function">Str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span><span class="token function">int</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-预声明类型-20-个-pre-declared-types" tabindex="-1"><a class="header-anchor" href="#_2-预声明类型-20-个-pre-declared-types" aria-hidden="true">#</a> 2.预声明类型（20 个）pre-declared types</h4><p>基本类型中的 20 个预声明简单类型都是命名类型</p><p>bool,1</p><p>int,int8,int16,int32,int64,uint,uint8,uint16,uint32,uint64,10</p><p>uintptr,1</p><p>float32,float64,2</p><p>complex64,complex128,2</p><p>byte(int8 别名),1</p><p>rune(int32 别名),1</p><p>string,1</p><p>error,1(唯一的接口)</p><h4 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h4><p>使用<code>type关键</code>字和<code>预声明的20个</code></p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>命名类型
<span class="token keyword">type</span> Myint <span class="token builtin">int</span>
<span class="token keyword">type</span> MyByte <span class="token builtin">byte</span>
<span class="token keyword">type</span> Myxxx <span class="token builtin">bool</span><span class="token punctuation">,</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token builtin">rune</span><span class="token punctuation">,</span><span class="token builtin">string</span><span class="token punctuation">,</span><span class="token builtin">uintptr</span><span class="token punctuation">,</span><span class="token builtin">error</span>
<span class="token keyword">type</span> Person <span class="token keyword">struct</span><span class="token punctuation">{</span>
	name <span class="token builtin">string</span>
	age <span class="token builtin">int</span>
<span class="token punctuation">}</span>
<span class="token keyword">type</span> new_type old_type
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="未命名类型-type-literals" tabindex="-1"><a class="header-anchor" href="#未命名类型-type-literals" aria-hidden="true">#</a> 未命名类型 type literals</h3><h4 id="未命名类型别称类型字面量-而且复合类型-类型字面量-未命名类型是同一个概念" tabindex="-1"><a class="header-anchor" href="#未命名类型别称类型字面量-而且复合类型-类型字面量-未命名类型是同一个概念" aria-hidden="true">#</a> 未命名类型别称类型字面量，而且复合类型，类型字面量，未命名类型是同一个概念</h4><p><code>由预声明类型，关键字和操作符组合而成</code></p><p>基本类型中的复合类型：<strong>array,slice,map,channel,pointer,function,struct,interface</strong></p><p>还有这种 a:= struct{...} 以 struct<strong>字面量</strong>声明的未命名类型，以及[]int,[]T1 都是 type interals</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>a<span class="token operator">:=</span><span class="token keyword">struct</span><span class="token punctuation">{</span>
  name <span class="token builtin">string</span>
  age <span class="token builtin">int</span>
<span class="token punctuation">}</span>
a<span class="token operator">:=</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token keyword">var</span> b <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="例子-1" tabindex="-1"><a class="header-anchor" href="#例子-1" aria-hidden="true">#</a> 例子</h4><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code>p <span class="token operator">:=</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>
	name <span class="token builtin">string</span>
	age <span class="token builtin">int</span>
<span class="token punctuation">}</span>
a <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span>
b <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
c <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int64</span>
d <span class="token operator">:=</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="底层类型" tabindex="-1"><a class="header-anchor" href="#底层类型" aria-hidden="true">#</a> 底层类型</h3><p><code>预声明类型</code>和<code>未命名类型</code>底层类型是他们自身，两者是终点</p><p><code>自定义类型</code>的底层类型是逐层递归向下查找，直到查到是预声明类型或者未命名类型</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> T1 <span class="token builtin">string</span>
<span class="token keyword">type</span> T2 T1

<span class="token keyword">type</span> T3 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token keyword">type</span> T4 T3

<span class="token keyword">type</span> T5 <span class="token punctuation">[</span><span class="token punctuation">]</span>T1
<span class="token keyword">type</span> T6 T5

<span class="token comment">// T1,T2 底层类型都是string</span>
<span class="token comment">// T3,T4 底层类型都是[]string</span>
<span class="token comment">// T5,T6 底层类型是[]T1,</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="类型相同" tabindex="-1"><a class="header-anchor" href="#类型相同" aria-hidden="true">#</a> 类型相同</h4><p>1.命名类型相同，就是要类型声明完全相同</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> T1 <span class="token builtin">string</span>
<span class="token keyword">type</span> T2 <span class="token builtin">string</span>
<span class="token comment">// T1 和 T2 不同, type后名字不一样</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>2.命名类型和未命名类型总是不相同</p><p>3.两个未命名类型相同的条件是它们的类型声明宇面量的结构相同，并且内部元素的类 型相同</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">var</span> m1 <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span>
m1 <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> m2 <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span> <span class="token operator">=</span> m2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.通过类型别名语句声明的两个类型相同</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> T1 <span class="token operator">=</span> T2
<span class="token comment">// 注意和1的区别</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="类型赋值" tabindex="-1"><a class="header-anchor" href="#类型赋值" aria-hidden="true">#</a> 类型赋值</h3><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// a 是 T1类型</span>
<span class="token keyword">var</span> b T2 <span class="token operator">=</span> a
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>必须满足如下一个条件</p><p>1.T1 和 T2 类型相同</p><p>2.T1 和 T2 有相同底层类型，并且 T1 和 T2 至少有一个未命名类型</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">type</span> Map1 <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token keyword">type</span> Map2 Map1

m3 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> m1 Map1 <span class="token operator">=</span> m3
<span class="token comment">// var m1 Map1 = m1 不行，没有一个未命名类型，需要强转</span>

<span class="token keyword">type</span> T1 <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">string</span>
<span class="token keyword">type</span> T2 <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">string</span>
t1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span>T1<span class="token punctuation">)</span>
<span class="token keyword">var</span> t2 <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token builtin">string</span> <span class="token operator">=</span> t1
<span class="token comment">// var t2 T2 = t1 不行，同上</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="方法调用" tabindex="-1"><a class="header-anchor" href="#方法调用" aria-hidden="true">#</a> 方法调用</h3><h4 id="一般调用" tabindex="-1"><a class="header-anchor" href="#一般调用" aria-hidden="true">#</a> 一般调用</h4><p>var t=&amp;T{}</p><p>t.Get()</p><h4 id="方法值" tabindex="-1"><a class="header-anchor" href="#方法值" aria-hidden="true">#</a> 方法值</h4><p>带有闭包的函数变量</p><p>t.Set = f</p><p>f(t)</p><h4 id="方法表达式" tabindex="-1"><a class="header-anchor" href="#方法表达式" aria-hidden="true">#</a> 方法表达式</h4><p>T.Set()</p><p>(*T).Get</p><p>第一个参数是接受者</p><h4 id="方法集" tabindex="-1"><a class="header-anchor" href="#方法集" aria-hidden="true">#</a> 方法集</h4><p>接收者为值类型 T 的方法集合记录为 S，接收者为指针类型*T 的方法集合记录为 *S</p><p>T 类型的方法集是 S</p><p>*T 类型的方法集是 S 和 *S（ *S 本质是自动生成的方法，并且是 ( *d).S，操作的非指针而是值）</p><p><strong>对于是否实现接口类型判断起作用</strong></p><h3 id="值调用和方法集调用的方法集合" tabindex="-1"><a class="header-anchor" href="#值调用和方法集调用的方法集合" aria-hidden="true">#</a> 值调用和方法集调用的方法集合</h3><p>通过类型变量（类型实例）进行值调用，编译器会自动转</p><p>使用表达式调用，编译器不会自动转</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">type</span> Data <span class="token keyword">struct</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>d Data<span class="token punctuation">)</span> <span class="token function">TestValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>d <span class="token operator">*</span>Data<span class="token punctuation">)</span> <span class="token function">TestPointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">type</span> Dd <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">TestValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">TestPointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 显示调用</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>Data<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">TestValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>Data<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">TestPointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">(</span>Data<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">TestValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// (Data)(struct{}{}).Test2() // 编译不过,Cannot call a pointer method on &#39;(Data)(struct{}{})&#39;</span>

	<span class="token comment">// 一般调用，值调用，类型变量调用，类型实例调用 会自动转换</span>
	<span class="token keyword">var</span> a Data <span class="token comment">// 方法集包含 valuefunc</span>
	a<span class="token punctuation">.</span><span class="token function">TestValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	a<span class="token punctuation">.</span><span class="token function">TestPointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">var</span> b <span class="token operator">*</span>Data <span class="token operator">=</span> <span class="token operator">&amp;</span>Data<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 方法集包含 valuefunc pointerfunc(自动生成，严格显示调用通过)</span>
	b<span class="token punctuation">.</span><span class="token function">TestValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	b<span class="token punctuation">.</span><span class="token function">TestPointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">// 表达式调用</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>Data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">TestValue</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>Data<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">TestPointer</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	Data<span class="token punctuation">.</span><span class="token function">TestValue</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	<span class="token comment">// Data.TestPointer(a) // 编译不过,cannot call pointer method TestPointer on Data</span>

	<span class="token comment">// var _ Dd = a // 编译不过,Cannot use &#39;a&#39; (type Data) as the type Dd Type does not implement &#39;Dd&#39; as the &#39;TestPointer&#39; method has a pointer receiver</span>
	<span class="token keyword">var</span> <span class="token boolean">_</span> Dd <span class="token operator">=</span> b <span class="token comment">// 说明</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,63);function h(g,y){const a=c("ExternalLinkIcon");return t(),p("div",null,[d,n("p",null,[n("a",k,[i("https://zhuanlan.zhihu.com/p/447224382"),o(a)])]),v,m,b])}const T=e(r,[["render",h],["__file","基础.html.vue"]]);export{T as default};
