import{_ as s,W as i,X as o,Y as e,Z as a,$ as l,a0 as t,C as r}from"./framework-52f8fb67.js";const d="/assets/mysql-operating-principle-af8e5261.png",p="/assets/mysql-innodb-store-950028a3.png",c="/assets/mysql-innodb-page-header-24dc84e4.png",h="/assets/mysql-innodb-page-datarow-6b7195d4.png",u="/assets/mysql-innodb-row-varchar-84942032.png",b="/assets/mysql-innodb-page-page-header-f3591bfd.png",f="/assets/mysql-innodb-B_tree-16ea0c03.png",m={},g=t('<h1 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql" aria-hidden="true">#</a> mysql</h1><h2 id="运行原理" tabindex="-1"><a class="header-anchor" href="#运行原理" aria-hidden="true">#</a> 运行原理</h2><figure><img src="'+d+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="连接池" tabindex="-1"><a class="header-anchor" href="#连接池" aria-hidden="true">#</a> 连接池</h2><p>mysql 服务和客户端的通信，mysql 服务侧有连接池，有自我保护</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>最大连接数
show variables like <span class="token string">&#39;max_connections&#39;</span><span class="token punctuation">;</span>
<span class="token builtin class-name">set</span> global <span class="token assign-left variable">max_connections</span><span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span>
单次最大数据报文
show variables like <span class="token string">&#39;max_allowed_packet&#39;</span><span class="token punctuation">;</span>
<span class="token builtin class-name">set</span> global <span class="token assign-left variable">max_allowed_packet</span><span class="token operator">=</span><span class="token number">83888608</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>sql解析器将sql优化成sql<code>执行计划</code>，并且由<code>存储引擎</code>来负责执行（实际是执行器通过存储引擎的handler api获取结果）</p><h2 id="数据写入" tabindex="-1"><a class="header-anchor" href="#数据写入" aria-hidden="true">#</a> 数据写入</h2><p>由于内存速度比磁盘快太多，所以<code>存储引擎（innodb）</code>所有逻辑读取和写入操作都是先在内存进行，此内存缓存区就是 buffer pool</p><p>具体步骤：</p><ol><li>执行器写磁盘负责事务的undo log</li><li>写buffer pool，同时需要记录到磁盘，看3和4，防止断电数据丢失</li><li>同时写入redo log buffer</li><li>需要把3的内存数据刷入磁盘，此时有三种策略刷盘 <ol><li>通过<code>innodb_flush_log_at_trx_commit</code>设置，值为0，1，2 <ul><li>1，实时刷盘</li><li>0，只写redo log buffer，per 1s刷盘</li><li>2，写redo log buffer和操作系统内存（page cache），per 1s 在写入磁盘</li></ul></li><li>断电了，优先从redo log磁盘文件恢复</li></ol></li><li>写redo log的同时，开始写binlog磁盘文件，可用于数据历史查询，数据备份，数据恢复，主从复制等</li><li>5写binlog成功后会告诉redo log事务已提交，redo log会打入commit标记</li><li>buffer pool 刷盘ibd文件，调用系统函数open，write，并且使用O_DIRECT跳过内核提供的page cache，innodb自己实现了一套高效缓存</li></ol><h2 id="存储结构" tabindex="-1"><a class="header-anchor" href="#存储结构" aria-hidden="true">#</a> 存储结构</h2><figure><img src="`+p+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>innodb主要两个文件，frm文件存表结构信息，ibd文件存数据和索引（也叫独立表空间，5.7后每个表独立一个ibd）</p><p><code>innodb_file_per_table</code> 来关闭或者开启，5.7默认为on</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">set</span> @@global.innodb_file_per_table <span class="token operator">=</span> on
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>表空间一共有5类，系统表空间ibdata1，独立表空间ibd（可压缩，可传输对比前者），undo表空间innodb_undo.ibu，通用表空间diy.ibd，临时表空间ibtmp1</p><h3 id="ibd文件" tabindex="-1"><a class="header-anchor" href="#ibd文件" aria-hidden="true">#</a> ibd文件</h3><h4 id="页" tabindex="-1"><a class="header-anchor" href="#页" aria-hidden="true">#</a> 页</h4><p><code>ibd</code>最小单元是页，所以每次数据读取的最小单位是页，每个页内部内存地址是连续的，这样减少磁盘的随机读写，降低耗时，页的大小默认是<code>16KB</code></p><p>页的种类是12种之多，所有页都有页头file header和页尾file trailer</p><h4 id="索引页" tabindex="-1"><a class="header-anchor" href="#索引页" aria-hidden="true">#</a> 索引页</h4><p>页头file header和页尾file trailer，中间是数据行，也就是常见的表数据</p><h5 id="数据行" tabindex="-1"><a class="header-anchor" href="#数据行" aria-hidden="true">#</a> 数据行</h5><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>查看表的行类型
<span class="token keyword">select</span> t.space,t.name,t.row_format from information_schema.INNODB_SYS_TABLESPACES t WHERE <span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&#39;dbname&#39;</span>

show variables like <span class="token string">&#39;innodb_default_row_format&#39;</span><span class="token punctuation">;</span>
<span class="token builtin class-name">set</span> <span class="token assign-left variable">innodb_default_row_format</span><span class="token operator">=</span><span class="token string">&#39;DYNAMIC&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>The row format of a table determines how its rows are physically stored, which in turn can affect the performance of queries and DML operations. As more rows fit into a single disk page, queries and index lookups can work faster, less cache memory is required in the buffer pool, and less I/O is required to write out updated values. The InnoDB storage engine supports four row formats: REDUNDANT, COMPACT, DYNAMIC, and COMPRESSED.</p><p>5.7默认DYNAMIC</p></blockquote><p>大小不固定，最大为<code>8KB</code></p><h4 id="区" tabindex="-1"><a class="header-anchor" href="#区" aria-hidden="true">#</a> 区</h4><p>业务数据越来越多，跨页读比较多，所以尽可能连续，否则磁头物理移动非常耗时（机械硬盘，ssd应该没这个问题）</p><p>所以引入区，每个区固定1MB，存放64页，这样范围查找的数据大概率在一个区内，只需要把这个区一起加载到内存</p><p>一开始创建表，本着不浪费，只会创建6个页（16*6=96KB ），而不是一个区</p><blockquote><p>We create a new generic empty tablespace. We initially let it be 4 pages: page 0 is the fsp header and an extent descriptor page, page 1 is an ibuf bitmap page, page 2 is the first inode page, page 3 will contain the root of the clustered index of the first table we create here.</p></blockquote><p>数据逐渐多了后，32页后就直接申请区了</p><h3 id="组" tabindex="-1"><a class="header-anchor" href="#组" aria-hidden="true">#</a> 组</h3><p>区越来越多，引入了组结构，一个组是256个区，<code>256MB</code></p><h3 id="段" tabindex="-1"><a class="header-anchor" href="#段" aria-hidden="true">#</a> 段</h3><p>和页，区，组不同，不是<code>物理区域</code>，而是<code>逻辑概念</code></p><p>non-leaf node segment 非叶子节点段，存储和管理索引树</p><p>leaf node segment 叶子节点段，存储和管理实际数据</p><p>逻辑上来说，由以上两种段构成了表空间的ibd文件</p><h2 id="sql执行原理" tabindex="-1"><a class="header-anchor" href="#sql执行原理" aria-hidden="true">#</a> sql执行原理</h2><p>sql执行过程</p><ol><li><p>客户端通过连接驱动连接到mysql的连接池</p></li><li><p>先通过查询缓存，查到直接返回（5.7默认关闭了，8.0直接删除这个功能了）</p><ol><li><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>show variables like <span class="token string">&#39;query_cache_type&#39;</span><span class="token punctuation">;</span>
<span class="token builtin class-name">set</span> query_cache_type <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>实际用处不大，hit概率太小，每次都查就显得耗费性能了</p></li></ol></li><li><p>通过sql解析器来解析sql</p><ol><li>词法分析</li><li>语法分析</li></ol></li><li><p>预处理器处理请求，也会进行语法验证，比如表，列是否存在，别名歧义等</p><ol><li>先提交sql模板</li><li>提交参数（使用同一个模板只要提交模板一次，多次提交参数执行即可）</li></ol></li><li><p>sql优化器，对sql进行优化，通过CBO（costbased optimization）选择成本最小的执行计划（io成本和cpu成本消耗值），最终会输出一个可执行的执行计划</p><ol><li><p>查看任意语句的优化细节</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>show variables like <span class="token string">&#39;OPTIMIZER_TRACE&#39;</span><span class="token punctuation">;</span>
SET <span class="token assign-left variable">OPTIMIZER_TRACE</span><span class="token operator">=</span><span class="token string">&quot;enabled=on&quot;</span>,END_MARKERS_IN_JSON<span class="token operator">=</span>on<span class="token punctuation">;</span>
SET <span class="token assign-left variable">optimizer_trace_offset</span><span class="token operator">=</span>-30, <span class="token assign-left variable">optimizer_trace_limit</span><span class="token operator">=</span><span class="token number">30</span><span class="token punctuation">;</span>
执行业务sql
查看
SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE<span class="token punctuation">;</span>
查完记得关闭
SET <span class="token assign-left variable">OPTIMIZER_TRACE</span><span class="token operator">=</span><span class="token string">&quot;enabled=off&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>也可以查询当前session会话中执行sql语句的查询成本</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>执行业务sql
show status like <span class="token string">&#39;last_query_cost&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ol></li><li><p>变成执行计划后，交给执行器来处理</p></li><li><p>执行器按照执行计划的需求通过<code>存储引擎</code>的<code>handler api</code>去获取这些结果，7之前都是在应用层</p><ol><li>命令增删改查</li><li>读，从buffer pool，磁盘文件ibd加载内存读取数据</li><li>写，先写入负责事务回滚undo buffer 刷盘undo log，再写redo buffer，刷盘redo log，再写入buffer pool，再写入double write buffer，刷盘到ibdata1系统表空间中，最终刷入磁盘ibd文件，参见上面的数据写入</li></ol></li><li><p>返回结果给客户端</p></li></ol><h2 id="页-1" tabindex="-1"><a class="header-anchor" href="#页-1" aria-hidden="true">#</a> 页</h2><p>包含页头，页尾，数据页</p><h3 id="页头file-header" tabindex="-1"><a class="header-anchor" href="#页头file-header" aria-hidden="true">#</a> 页头file header</h3><p>占用<code>38字节</code></p><figure><img src="`+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>页号，4个字节，32个bit，大约可以存储2<sup>32</sup>大约42亿个页</p><p>上下页号，组成双向链表</p><h3 id="页尾file-trailer" tabindex="-1"><a class="header-anchor" href="#页尾file-trailer" aria-hidden="true">#</a> 页尾file trailer</h3><p>占用<code>8字节</code></p><p>包含校验和，最近一次修改的LSN</p><p>操作系统传输单元数据库通常是4KB，正好一页是4个数据块，断电情况可能就会<code>缺页</code>，就需要通过校验和来验证，默认使用crc32算法，通过<code>innodb_checksum_algorithm</code>查看</p><h3 id="数据行-1" tabindex="-1"><a class="header-anchor" href="#数据行-1" aria-hidden="true">#</a> 数据行</h3><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>包含额外信息，真实数据</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>varchar 实际存储在溢出页，用2个字节来表示这个字段的长度，16个bit可以表示最大65536个字节，本身消耗最多两个字节来记录长度，65534个字节，最大按照4个字节一个字符算，65534/4=16383个字符</p><h3 id="页目录" tabindex="-1"><a class="header-anchor" href="#页目录" aria-hidden="true">#</a> 页目录</h3><p>提升数据行的二分查找，将所有页进行分组，每个组8个数据行，每个组放入一个槽位</p><p>查找流程：先定位某个槽，再从最多8个行中遍历</p><h3 id="数据页头page-header" tabindex="-1"><a class="header-anchor" href="#数据页头page-header" aria-hidden="true">#</a> 数据页头page header</h3><p>56个字节构成了page header，主要放入统计和通用信息</p><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h2><p>B树范围查找不行，查询效率不稳定，离root节点近就快，远就慢，树的高度不够低</p><p>B+树去处每个非叶子节点的真实数据，用来存放更多的子节点，查询效率和树的高度高的问题就解决来，叶子节点存储所有上层父节点的真实数据，</p><p>一个16KB页可以存储三四百个&quot;key+下一页地址&quot;的行</p><p>log(400)20000000=2.69 大约3层树高</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',71),_=e("p",null,"聚簇索引/主键索引",-1),v={href:"http://key.To",target:"_blank",rel:"noopener noreferrer"},k=e("p",null,"When you define a PRIMARY KEY on a table, InnoDB uses it as the clustered index. A primary key should be defined for each table. If there is no logical unique and non-null column or set of columns to use a the primary key, add an auto-increment column. Auto-increment column values are unique and are added automatically as new rows are inserted.",-1),y=e("p",null,"If you do not define a PRIMARY KEY for a table, InnoDB uses the first UNIQUE index with all key columns defined as NOT NULL as the clustered index.",-1),x=e("p",null,"If a table has no PRIMARY KEY or suitable UNIQUE index, InnoDB generates a hidden clustered index named GEN_CLUST_INDEX on a synthetic column that contains row ID values.The rows are ordered by the row ID that InnoDB assigns. The row ID is a 6-byte field that increases monotonically as new rows are inserted. Thus, the rows ordered by the row ID are physically in order of insertion.",-1),q=e("blockquote",null,[e("p",null,"每个页中至少有两行 The maximum row size, excluding any variable-length columns that are stored off-page, is slightly less than half of a page for 4KB, 8KB, 16KB, and 32KB page sizes. For example, the maximum row size for the default innodb_page_size of 16KB is about 8000 bytes.")],-1),w=e("blockquote",null,[e("p",null,"行长度限制 The internal representation of a MySQL table has a maximum row size limit of 65,535 bytes, even if the storage engine is capable of supporting larger rows.BLOB and TEXT columns only contribute 9 to 12 bytes toward the row size limit because their contents are stored separately from the rest of the row.")],-1);function I(E,T){const n=r("ExternalLinkIcon");return i(),o("div",null,[g,e("blockquote",null,[_,e("p",null,[a("Each InnoDB table has a special index called the clustered index that stores row data. Typically, the clustered index is synonymous with the primary "),e("a",v,[a("key.To"),l(n)]),a(" get the best performance from queries, inserts, and other database operations, it is important to understand how InnoDB uses the clustered index to optimize the common lookup and DML.")]),k,y,x]),q,w])}const D=s(m,[["render",I],["__file","mysql.html.vue"]]);export{D as default};
