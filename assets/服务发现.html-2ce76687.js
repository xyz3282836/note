import{_ as t,W as c,X as i,Y as s,Z as n,$ as a,a0 as o,C as l}from"./framework-52f8fb67.js";const p={},d=o(`<h1 id="服务发现" tabindex="-1"><a class="header-anchor" href="#服务发现" aria-hidden="true">#</a> 服务发现</h1><h2 id="前提" tabindex="-1"><a class="header-anchor" href="#前提" aria-hidden="true">#</a> 前提</h2><p>服务注册与发现最简单的就是<code>direct</code>固定服务端地址的直连方式。也就是服务端正常监听端口启动不进行额外操作，客户端使用如下<code>target</code>：</p><div class="language-url line-numbers-mode" data-ext="url"><pre class="language-url"><code><span class="token scheme">direct<span class="token scheme-delimiter">:</span></span><span class="token authority"><span class="token authority-delimiter">//</span><span class="token host">default</span></span><span class="token path"><span class="token path-separator">/</span>127.0.0.1:9000,127.0.0.1:9091</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,4),r=s("code",null,"target",-1),u=s("code",null,"URL",-1),v={href:"https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6",target:"_blank",rel:"noopener noreferrer"},k=s("p",null,[n("其中"),s("code",null,"direct"),n("为协议类型，此处表示直接使用该"),s("code",null,"URL"),n("内提供的地址"),s("code",null,"127.0.0.1:9000,127.0.0.1:9091"),n("进行连接，而"),s("code",null,"default"),n("在此处无意义仅当做占位符。")],-1),m=s("h2",{id:"grpc-resolver",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#grpc-resolver","aria-hidden":"true"},"#"),n(" gRPC Resolver")],-1),b=s("code",null,"resolver.Builder",-1),g=s("code",null,"resolver.ClientConn",-1),h=s("code",null,"resolver.Resolver",-1),_={href:"https://github.com/grpc/grpc-go/blob/master/resolver/resolver.go",target:"_blank",rel:"noopener noreferrer"},f=o(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// Builder creates a resolver that will be used to watch name resolution updates.</span>
<span class="token keyword">type</span> Builder <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token comment">// Build creates a new resolver for the given target.</span>
    <span class="token comment">//</span>
    <span class="token comment">// gRPC dial calls Build synchronously, and fails if the returned error is</span>
    <span class="token comment">// not nil.</span>
    <span class="token function">Build</span><span class="token punctuation">(</span>target Target<span class="token punctuation">,</span> cc ClientConn<span class="token punctuation">,</span> opts BuildOption<span class="token punctuation">)</span> <span class="token punctuation">(</span>Resolver<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
    <span class="token comment">// Scheme returns the scheme supported by this resolver.</span>
    <span class="token comment">// Scheme is defined at https://github.com/grpc/grpc/blob/master/doc/naming.md.</span>
    <span class="token function">Scheme</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token comment">// ClientConn contains the callbacks for resolver to notify any updates</span>
<span class="token comment">// to the gRPC ClientConn.</span>
<span class="token comment">//</span>
<span class="token comment">// This interface is to be implemented by gRPC. Users should not need a</span>
<span class="token comment">// brand new implementation of this interface. For the situations like</span>
<span class="token comment">// testing, the new implementation should embed this interface. This allows</span>
<span class="token comment">// gRPC to add new methods to this interface.</span>
<span class="token keyword">type</span> ClientConn <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token comment">// UpdateState updates the state of the ClientConn appropriately.</span>
    <span class="token function">UpdateState</span><span class="token punctuation">(</span>State<span class="token punctuation">)</span>
    <span class="token comment">// NewAddress is called by resolver to notify ClientConn a new list</span>
    <span class="token comment">// of resolved addresses.</span>
    <span class="token comment">// The address list should be the complete list of resolved addresses.</span>
    <span class="token comment">//</span>
    <span class="token comment">// Deprecated: Use UpdateState instead.</span>
    <span class="token function">NewAddress</span><span class="token punctuation">(</span>addresses <span class="token punctuation">[</span><span class="token punctuation">]</span>Address<span class="token punctuation">)</span>
    <span class="token comment">// NewServiceConfig is called by resolver to notify ClientConn a new</span>
    <span class="token comment">// service config. The service config should be provided as a json string.</span>
    <span class="token comment">//</span>
    <span class="token comment">// Deprecated: Use UpdateState instead.</span>
    <span class="token function">NewServiceConfig</span><span class="token punctuation">(</span>serviceConfig <span class="token builtin">string</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// Resolver watches for the updates on the specified target.</span>
<span class="token comment">// Updates include address updates and service config updates.</span>
<span class="token keyword">type</span> Resolver <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token comment">// ResolveNow will be called by gRPC to try to resolve the target name</span>
    <span class="token comment">// again. It&#39;s just a hint, resolver can ignore this if it&#39;s not necessary.</span>
    <span class="token comment">//</span>
    <span class="token comment">// It could be called multiple times concurrently.</span>
    <span class="token function">ResolveNow</span><span class="token punctuation">(</span>ResolveNowOption<span class="token punctuation">)</span>
    <span class="token comment">// Close closes the resolver.</span>
    <span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面依次分析这三个接口的作用：</p><ul><li><code>Builder</code>用于gRPC内部创建<code>Resolver</code>接口的实现，但注意声明的<code>Build</code>方法将接口<code>ClientConn</code>作为参数传入了</li><li><code>ClientConn</code>接口有两个废弃方法不用管，看<code>UpdateState</code>方法需要传入<code>State</code>结构，看代码可以发现其中包含了<code>Addresses []Address // Resolved addresses for the target</code>，可以看出是需要将服务发现得到的<code>Address</code>对象列表告诉<code>ClientConn</code>的对象</li><li><code>Resolver</code>提供了<code>ResolveNow</code>用于被gRPC尝试重新进行服务发现</li></ul><p>看完这三个接口就可以明白gRPC的服务发现实现逻辑，通过<code>Builder</code>进行<code>Reslover</code>的创建，在<code>Build</code>的过程中将服务发现的地址信息丢给<code>ClientConn</code>用于内部连接创建等逻辑。主要逻辑可以按下面顺序来看源码理解：</p>`,4),y=s("code",null,"client",-1),C=s("code",null,"Dial",-1),w=s("code",null,"target",-1),R=s("code",null,"scheme",-1),B=s("code",null,"Builder",-1),q={href:"https://github.com/grpc/grpc-go/blob/master/clientconn.go#L242",target:"_blank",rel:"noopener noreferrer"},x=s("code",null,"Dial",-1),N=s("code",null,"ClientConn",-1),A={href:"https://github.com/grpc/grpc-go/blob/master/clientconn.go#L447",target:"_blank",rel:"noopener noreferrer"},D=s("code",null,"ClientConn",-1),P=s("code",null,"ClientConn",-1),S=s("code",null,"resolverWrapper",-1),E=s("code",null,"ClientConn",-1),I={href:"https://github.com/grpc/grpc-go/blob/master/resolver_conn_wrapper.go",target:"_blank",rel:"noopener noreferrer"},U=s("code",null,"resolverWrapper",-1),L=s("code",null,"Build",-1),T={href:"https://github.com/grpc/grpc-go/blob/master/resolver_conn_wrapper.go#L89",target:"_blank",rel:"noopener noreferrer"},W=s("code",null,"ClientConn",-1),O=s("code",null,"ccResolverWrapper",-1),F=s("code",null,"Builder",-1),V=s("code",null,"UpdateState",-1),z=s("code",null,"ClientConn",-1),Z=s("code",null,"updateResolverState",-1),j={href:"https://github.com/grpc/grpc-go/blob/master/resolver_conn_wrapper.go#L109",target:"_blank",rel:"noopener noreferrer"},H=s("code",null,"updateResolverState",-1),$=s("code",null,"Address",-1),K={href:"https://github.com/grpc/grpc-go/blob/master/clientconn.go#L553",target:"_blank",rel:"noopener noreferrer"},X=s("code",null,"Address",-1),Y={href:"https://github.com/grpc/grpc-go/blob/master/resolver/resolver.go#L79",target:"_blank",rel:"noopener noreferrer"},G=o(`<p>所以<code>warden</code>包装了gRPC的整个服务发现实现逻辑，代码分别位于<code>pkg/naming/naming.go</code>和<code>warden/resolver/resolver.go</code>，其中：</p><ul><li><code>naming.go</code>内定义了用于描述业务实例的<code>Instance</code>结构、用于服务注册的<code>Registry</code>接口、用于服务发现的<code>Resolver</code>接口</li><li><code>resolver.go</code>内实现了gRPC官方的<code>resolver.Builder</code>和<code>resolver.Resolver</code>接口，但也暴露了<code>naming.go</code>内的<code>naming.Builder</code>和<code>naming.Resolver</code>接口</li></ul><h2 id="warden-resolver" tabindex="-1"><a class="header-anchor" href="#warden-resolver" aria-hidden="true">#</a> warden Resolver</h2><p>接下来看<code>naming</code>内的接口如下：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// Resolver resolve naming service</span>
<span class="token keyword">type</span> Resolver <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Fetch</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>InstancesInfo<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>
    <span class="token function">Watch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">}</span>

<span class="token comment">// Builder resolver builder.</span>
<span class="token keyword">type</span> Builder <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Build</span><span class="token punctuation">(</span>id <span class="token builtin">string</span><span class="token punctuation">)</span> Resolver
    <span class="token function">Scheme</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到封装方式与gRPC官方的方法一样，通过<code>Builder</code>进行<code>Resolver</code>的初始化。不同的是通过封装将参数进行了简化：</p><ul><li><code>Build</code>只需要传对应的服务<code>id</code>即可：<code>warden/resolver/resolver.go</code>在gRPC进行调用后，会根据<code>Scheme</code>方法查询对应的<code>naming.Builder</code>实现并调用<code>Build</code>将<code>id</code>传入，而<code>naming.Resolver</code>的实现即可通过<code>id</code>去对应的服务发现中间件进行实例信息的查询</li><li>而<code>Resolver</code>则对方法进行了扩展，除了简单进行<code>Fetch</code>操作外还多了<code>Watch</code>方法，用于监听服务发现中间件的节点变化情况，从而能够实时的进行服务实例信息的更新</li></ul>`,7),J=s("code",null,"naming/discovery",-1),M={href:"https://github.com/bilibili/discovery",target:"_blank",rel:"noopener noreferrer"},Q=s("code",null,"etcd",-1),nn=s("code",null,"zookeeper",-1),sn=s("code",null,"naming/discovery/discovery.go",-1),en=s("code",null,"discovery",-1),an=s("h2",{id:"使用discovery",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#使用discovery","aria-hidden":"true"},"#"),n(" 使用discovery")],-1),on=s("code",null,"warden",-1),tn=s("code",null,"direct",-1),cn={href:"https://github.com/bilibili/discovery",target:"_blank",rel:"noopener noreferrer"},ln=s("code",null,"NewClient",-1),pn=o(`<div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token keyword">package</span> dao

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">&quot;context&quot;</span>

    <span class="token string">&quot;github.com/bilibili/kratos/pkg/naming/discovery&quot;</span>
    <span class="token string">&quot;github.com/bilibili/kratos/pkg/net/rpc/warden&quot;</span>
    <span class="token string">&quot;github.com/bilibili/kratos/pkg/net/rpc/warden/resolver&quot;</span>

    <span class="token string">&quot;google.golang.org/grpc&quot;</span>
<span class="token punctuation">)</span>

<span class="token comment">// AppID your appid, ensure unique.</span>
<span class="token keyword">const</span> AppID <span class="token operator">=</span> <span class="token string">&quot;demo.service&quot;</span> <span class="token comment">// NOTE: example</span>

<span class="token comment">// NewClient new member grpc client</span>
<span class="token keyword">func</span> <span class="token function">NewClient</span><span class="token punctuation">(</span>cfg <span class="token operator">*</span>warden<span class="token punctuation">.</span>ClientConfig<span class="token punctuation">,</span> opts <span class="token operator">...</span>grpc<span class="token punctuation">.</span>DialOption<span class="token punctuation">)</span> <span class="token punctuation">(</span>DemoClient<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    client <span class="token operator">:=</span> warden<span class="token punctuation">.</span><span class="token function">NewClient</span><span class="token punctuation">(</span>cfg<span class="token punctuation">,</span> opts<span class="token operator">...</span><span class="token punctuation">)</span>
    conn<span class="token punctuation">,</span> err <span class="token operator">:=</span> client<span class="token punctuation">.</span><span class="token function">Dial</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;discovery://default/&quot;</span><span class="token operator">+</span>AppID<span class="token punctuation">)</span>
    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
    <span class="token punctuation">}</span>
    <span class="token comment">// 注意替换这里：</span>
    <span class="token comment">// NewDemoClient方法是在&quot;api&quot;目录下代码生成的</span>
    <span class="token comment">// 对应proto文件内自定义的service名字，请使用正确方法名替换</span>
    <span class="token keyword">return</span> <span class="token function">NewDemoClient</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意：<code>resolver.Register</code>是全局行为，建议放在包加载阶段或main方法开始时执行，该方法执行后会在gRPC内注册构造方法</p></blockquote><p><code>target</code>是<code>discovery://default/\${appid}</code>，当gRPC内进行解析后会得到<code>scheme</code>=<code>discovery</code>和<code>appid</code>，然后进行以下逻辑：</p><ol><li><code>warden/resolver.Builder</code>会通过<code>scheme</code>获取到<code>naming/discovery.Builder</code>对象（靠<code>resolver.Register</code>注册过的）</li><li>拿到<code>naming/discovery.Builder</code>后执行<code>Build(appid)</code>构造<code>naming/discovery.Discovery</code></li><li><code>naming/discovery.Discovery</code>对象基于<code>appid</code>就知道要获取哪个服务的实例信息</li></ol><h2 id="服务注册" tabindex="-1"><a class="header-anchor" href="#服务注册" aria-hidden="true">#</a> 服务注册</h2>`,5),dn={href:"https://github.com/bilibili/discovery",target:"_blank",rel:"noopener noreferrer"},rn={href:"https://github.com/bilibili/discovery",target:"_blank",rel:"noopener noreferrer"},un=o(`<p>相对服务发现来讲，服务注册则简单很多，看<code>naming/discovery/discovery.go</code>内的代码实现了<code>naming/naming.go</code>内的<code>Registry</code>接口，服务端启动时可以参考下面代码进行注册：</p><div class="language-go line-numbers-mode" data-ext="go"><pre class="language-go"><code><span class="token comment">// 该代码可放在main.go，当warden server进行初始化之后</span>
<span class="token comment">// 省略...</span>

ip <span class="token operator">:=</span> <span class="token string">&quot;&quot;</span> <span class="token comment">// NOTE: 必须拿到您实例节点的真实IP，</span>
port <span class="token operator">:=</span> <span class="token string">&quot;&quot;</span> <span class="token comment">// NOTE: 必须拿到您实例grpc监听的真实端口，warden默认监听9000</span>
hn<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Hostname</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
dis <span class="token operator">:=</span> discovery<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span>
ins <span class="token operator">:=</span> <span class="token operator">&amp;</span>naming<span class="token punctuation">.</span>Instance<span class="token punctuation">{</span>
    Zone<span class="token punctuation">:</span>     env<span class="token punctuation">.</span>Zone<span class="token punctuation">,</span>
    Env<span class="token punctuation">:</span>      env<span class="token punctuation">.</span>DeployEnv<span class="token punctuation">,</span>
    AppID<span class="token punctuation">:</span>    <span class="token string">&quot;your app id&quot;</span><span class="token punctuation">,</span>
    Hostname<span class="token punctuation">:</span> hn<span class="token punctuation">,</span>
    Addrs<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span>
        <span class="token string">&quot;grpc://&quot;</span> <span class="token operator">+</span> ip <span class="token operator">+</span> <span class="token string">&quot;:&quot;</span> <span class="token operator">+</span> port<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
cancel<span class="token punctuation">,</span> err <span class="token operator">:=</span> dis<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ins<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 省略...</span>

<span class="token comment">// 特别注意！！！</span>
<span class="token comment">// cancel必须在进程退出时执行！！！</span>
<span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2);function vn(kn,mn){const e=l("ExternalLinkIcon");return c(),i("div",null,[d,s("blockquote",null,[s("p",null,[r,n("就是标准的"),u,n("资源定位符"),s("a",v,[n("查看WIKI"),a(e)])])]),k,m,s("p",null,[n("gRPC暴露了服务发现的接口"),b,n("和"),g,n("和"),h,n("，"),s("a",_,[n("官方代码位置"),a(e)]),n("：")]),f,s("ul",null,[s("li",null,[n("当"),y,n("在"),C,n("时会根据"),w,n("解析的"),R,n("获取对应的"),B,n("，"),s("a",q,[n("官方代码位置"),a(e)])]),s("li",null,[n("当"),x,n("成功会创建出结构体"),N,n("的对象"),s("a",A,[n("官方代码位置"),a(e)]),n("(注意不是上面的"),D,n("接口)，可以看到结构体"),P,n("内的成员"),S,n("又实现了接口"),E,n("的方法"),s("a",I,[n("官方代码位置"),a(e)])]),s("li",null,[n("当"),U,n("被初始化时就会调用"),L,n("方法"),s("a",T,[n("官方代码位置"),a(e)]),n("，其中参数为接口"),W,n("传入的是"),O]),s("li",null,[n("当用户基于"),F,n("的实现进行"),V,n("调用时，则会触发结构体"),z,n("的"),Z,n("方法"),s("a",j,[n("官方代码位置"),a(e)]),n("，"),H,n("则会对传入的"),$,n("进行初始化等逻辑"),s("a",K,[n("官方代码位置"),a(e)])])]),s("p",null,[n("如此整个服务发现过程就结束了。从中也可以看出gRPC官方提供的三个接口还是很灵活的，但也正因为灵活要实现稍微麻烦一些，而"),X,s("a",Y,[n("官方代码位置"),a(e)]),n("如果直接被业务拿来用于服务节点信息的描述结构则显得有些过于简单。")]),G,s("p",null,[n("在"),J,n("内实现了基于"),s("a",M,[n("discovery"),a(e)]),n("为中间件的服务注册与发现逻辑。如果要实现其他中间件如"),Q,n("|"),nn,n("等的逻辑，参考"),sn,n("内的逻辑，将与"),en,n("的交互逻辑替换掉即可（后续会默认将etcd/zk等实现，敬请期待）。")]),an,s("p",null,[n("因为"),on,n("内默认使用"),tn,n("的方式，所以要使用"),s("a",cn,[n("discovery"),a(e)]),n("需要在业务的"),ln,n("前进行注册，代码如下：")]),pn,s("p",null,[n("客户端既然使用了"),s("a",dn,[n("discovery"),a(e)]),n("进行服务发现，也就意味着服务端启动后必须将自己注册给"),s("a",rn,[n("discovery"),a(e)]),n("知道。")]),un])}const gn=t(p,[["render",vn],["__file","服务发现.html.vue"]]);export{gn as default};
