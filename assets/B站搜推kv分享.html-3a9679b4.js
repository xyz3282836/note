import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as h,a as r}from"./app-6f5bc1f7.js";const d="/assets/image-20221024181314427-4f2f783a.png",i={},t=r('<h1 id="b-站-kv-搜索分享" tabindex="-1"><a class="header-anchor" href="#b-站-kv-搜索分享" aria-hidden="true">#</a> b 站 kv 搜索分享</h1><h3 id="场景" tabindex="-1"><a class="header-anchor" href="#场景" aria-hidden="true">#</a> 场景</h3><p>Data intensity ：亿级稿件选 top-N</p><p>latency sensitive：500ms</p><p>OLAP：列式存储，搜推场景</p><p>OLTP：行式存储，主站场景</p><h3 id="kv-分类" tabindex="-1"><a class="header-anchor" href="#kv-分类" aria-hidden="true">#</a> kv 分类</h3><p>embedded in memory kv: 语言提供的 map 存储</p><p>in memory kv srever: memcached, redis</p><p>embedded kv database: leveldb, rocksdb(基于 lsmtree)</p><p>distributed kv database: taishan, TiKV</p><p>complicated data-model: BigTable, MongoDB, Cassandra, Dynamo</p><p>data structure: B-tree, LSM-tree, hash-map</p><h3 id="embedded-in-memory-kv" tabindex="-1"><a class="header-anchor" href="#embedded-in-memory-kv" aria-hidden="true">#</a> Embedded in memory KV</h3><p>业务场景：每秒查询 20 亿个 key，20 kps，随机点读，random point read，10-20G，10w kps update</p><p>高频访问，存储不大，增量远远小于存量</p><p>选型是内存数据库 kv，数据结构 hashmap</p><p>对于高频，随机，点查场景有很多数据结构可以选择，skin-list，sorted-array，hash-map，btree，rbtree</p><p>hash-map 多种实现（核心问题是解决 key 冲突）：open-addressing，separate chaining，perfect-hash，cuckoo-hash（google 布谷鸟 hash，理论复杂度最坏是 O(1)，实际生成环境不理想，建立 hash 表无限循环，建立索引失败，依赖两个 hash 函数解决冲突；另外查询冲突的 key 离的比较远，效率就低了，cache 命中率比较低，不友好）</p><p>影响 hash 的几个因素：hash 函数，更少的指令计算更加均匀的 hash；计算 hash 分桶的过程（取模太慢），小的数据规模可以使用位操作，大的数据规模可以采用高 32 位*bucket 再去取高 32 位作为 bucket 的 index</p><h4 id="几种现在比较高效的-hash-结构" tabindex="-1"><a class="header-anchor" href="#几种现在比较高效的-hash-结构" aria-hidden="true">#</a> 几种现在比较高效的 hash 结构</h4><h5 id="robin-hood-hash" tabindex="-1"><a class="header-anchor" href="#robin-hood-hash" aria-hidden="true">#</a> robin-hood hash</h5><h5 id="flatmap" tabindex="-1"><a class="header-anchor" href="#flatmap" aria-hidden="true">#</a> flatmap</h5><h5 id="flat-hash-map-f14" tabindex="-1"><a class="header-anchor" href="#flat-hash-map-f14" aria-hidden="true">#</a> flat hash map（f14）</h5><p>并不适合当前业务场景，90%命中率，value 是指针 int64 地址</p><h5 id="neighbor-hash" tabindex="-1"><a class="header-anchor" href="#neighbor-hash" aria-hidden="true">#</a> neighbor hash</h5><p>采用 open-address，冲突放在最近，提高 cache 命中率</p><p>x64 架构下，64bit 地址只是使用了 48 位，用剩下的 16bit 来存放冲突的下个节点</p><h5 id="epoch-protection-framework" tabindex="-1"><a class="header-anchor" href="#epoch-protection-framework" aria-hidden="true">#</a> epoch protection framework</h5><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一次批量操作，只原子操作一次</p><h3 id="kfc" tabindex="-1"><a class="header-anchor" href="#kfc" aria-hidden="true">#</a> KFC</h3><p>remote kv store</p><p>参考 google mesa，apache doris</p><p>batch update 吞吐大</p><h5 id="nvme-backend" tabindex="-1"><a class="header-anchor" href="#nvme-backend" aria-hidden="true">#</a> nvme backend</h5><p>key 存放在内存，value 存放 nvme；复用 48bit value，1bit 作为标识是否是 cache 还是 nvme</p><h3 id="kv-in-parameter-server" tabindex="-1"><a class="header-anchor" href="#kv-in-parameter-server" aria-hidden="true">#</a> KV in parameter Server</h3>',38),n=[t];function s(p,o){return e(),h("div",null,n)}const b=a(i,[["render",s],["__file","B站搜推kv分享.html.vue"]]);export{b as default};
