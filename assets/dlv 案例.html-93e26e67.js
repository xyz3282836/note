import{_ as e,W as a,X as s,Y as n}from"./framework-7d39e0da.js";const l={},d=n(`<p>// 生成无内联优化的可执行二进制文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>go build <span class="token parameter variable">-gcflags</span> <span class="token string">&quot;-N -l&quot;</span> <span class="token parameter variable">-v</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>// 后台执行阻塞的 http server 程序</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nohub ./godlv
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>// 自动编译二进制文件，并且进入 dlv，并且可以使用 restart</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>dlv debug ./main.go
dlv debug godlv <span class="token punctuation">(</span>项目目录名称<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>// 使 Delve 控制一个已经运行的进程，并开始一个新的调试会话。 当退出调试会话时，你可以选择让该进程继续运行或杀死它。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>dlv attach pid
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进入 dlv 后</p><p>就是打断点，触发执行后停在该断点</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>b main.go:17 或者 b randHandler
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>c 就是 continue，下一个断点或者没有断点就结束了,如果结束后外部触发了会再次重新走第一个断点</p><p>help 会打印可供使用的命令</p><p>bp 列出所有断点，并且由序号，供 clear 删除使用</p><p>clearall 删除所有断点</p><p>clear 4</p><p>toggle 4 断点状态设置为不可用</p><p>s 执行下一行代码</p><p>n 执行代码的下一步</p><p>r restart 的 alias,重新开始 debug，attach 方式不行，需要 delve 自己创建的进程才可以，比如 dlv debug 的方式</p><p>si step-instruction 的 alias，针对汇编代码，否则和 step 一样</p><p>so stepout 的 alias，跳出当前函数，s 太慢，so 直接跳出当前函数，返回上层调用继续向下，比较方便</p><p>args 打印当前所在函数的参数值</p><p>locals 打印当前函数，执行此步之前的所有局部变量值，不是所有，只有执行到了才能打印</p><p>print 打印 locals 返回的局部变量以及参数，全局变量</p><p>whatis _xxb 打印变量类型</p><p>set 修改变量值,debug 非常有用，注意当前一步涉及的变量无法改动</p><p>vars main._xxb 打印所有全局变量，加上名称可以自动正则匹配（vars xb$)</p><p>funcs count 查看 count 方法</p><p>list 打印了很多东西，需要重新定位当前代码，非常有用</p><p>disass 查看当前汇编代码执行位置（s 代码执行一步，可能 si 要执行多次汇编指令）</p>`,31),i=[d];function p(t,r){return a(),s("div",null,i)}const o=e(l,[["render",p],["__file","dlv 案例.html.vue"]]);export{o as default};
