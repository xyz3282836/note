import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as n,o as l,c as d,b as e,d as i,e as r,a as p}from"./app-6f5bc1f7.js";const t={},o=p(`<h1 id="dlv-命令" tabindex="-1"><a class="header-anchor" href="#dlv-命令" aria-hidden="true">#</a> dlv 命令</h1><h2 id="基础" tabindex="-1"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h2><p>go build 可以用*-gcflags<em>给</em>go*编译器传入参数，也就是传给 go tool compile 的参数，因此可以用 go tool compile --help 查看所有可用的参数。</p><p>其中-m 可以检查代码的编译优化情况，包括逃逸情况和函数是否内联。</p><p>如果只在编译特定包时需要传递参数，格式应遵守“包名=参数列表”，如 go build -gcflags -gcflags=&#39;log=-N -l&#39; main.go</p><p>go build 用-ldflags 给 go 链接器传入参数，实际是给 go tool link 的参数，可以用 go tool link --help 查看可用的参数。</p><p>常用-X 来指定版本号等编译时才决定的参数值。例如代码中定义 var buildVer string，然后在编译时用 go build -ldflags &quot;-X main.buildVer=1.0&quot; ... 来赋值。注意-X 只能给 string 类型变量赋值。</p><h2 id="dlv" tabindex="-1"><a class="header-anchor" href="#dlv" aria-hidden="true">#</a> dlv</h2><p>// 生成无内联优化的可执行二进制文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>go build <span class="token parameter variable">-gcflags</span> <span class="token string">&quot;-N -l&quot;</span> <span class="token parameter variable">-v</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>// 后台执行阻塞的 http server 程序</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>nohub ./godlv
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>// 自动编译二进制文件，并且进入 dlv，并且可以使用 restart</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>dlv debug ./main.go
dlv debug godlv <span class="token punctuation">(</span>项目目录名称<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>// 使 Delve 控制一个已经运行的进程，并开始一个新的调试会话。 当退出调试会话时，你可以选择让该进程继续运行或杀死它。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>dlv attach pid
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进入 dlv 后</p><p>就是打断点，触发执行后停在该断点</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>b main.go:17 或者 b randHandler
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>c 就是 continue，下一个断点或者没有断点就结束了,如果结束后外部触发了会再次重新走第一个断点</p><p>help 会打印可供使用的命令</p><p>bp 列出所有断点，并且由序号，供 clear 删除使用</p><p>clearall 删除所有断点</p><p>clear 4</p><p>toggle 4 断点状态设置为不可用</p><p>s 执行下一行代码</p><p>n 执行代码的下一步</p><p>r restart 的 alias,重新开始 debug，attach 方式不行，需要 delve 自己创建的进程才可以，比如 dlv debug 的方式</p><p>si step-instruction 的 alias，针对汇编代码，否则和 step 一样</p><p>so stepout 的 alias，跳出当前函数，s 太慢，so 直接跳出当前函数，返回上层调用继续向下，比较方便</p><p>args 打印当前所在函数的参数值</p><p>locals 打印当前函数，执行此步之前的所有局部变量值，不是所有，只有执行到了才能打印</p><p>print 打印 locals 返回的局部变量以及参数，全局变量</p><p>whatis _xxb 打印变量类型</p><p>set 修改变量值,debug 非常有用，注意当前一步涉及的变量无法改动</p><p>vars main._xxb 打印所有全局变量，加上名称可以自动正则匹配（vars xb$)</p><p>funcs count 查看 count 方法</p><p>list 打印了很多东西，需要重新定位当前代码，非常有用</p><p>disass 查看当前汇编代码执行位置（s 代码执行一步，可能 si 要执行多次汇编指令）</p><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> reference</h2>`,40),c={href:"https://zhuanlan.zhihu.com/p/425645473",target:"_blank",rel:"noopener noreferrer"};function u(h,v){const a=n("ExternalLinkIcon");return l(),d("div",null,[o,e("p",null,[e("a",c,[i("https://zhuanlan.zhihu.com/p/425645473"),r(a)])])])}const m=s(t,[["render",u],["__file","dlv 命令.html.vue"]]);export{m as default};
